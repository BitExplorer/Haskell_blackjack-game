
==================== FINAL INTERFACE ====================
2019-05-05 01:28:53.4327317 UTC

interface main:Main 8064
  interface hash: ae2912f89eace28a7036458805d060b7
  ABI hash: 6aa0156f4fe78bae9d529a236d571772
  export-list hash: c24c272897a82c545af3d41fe83301a8
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: d99695e32fb9f9a604a24ed84e77d17d
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.announceWinner
  Main.beginRound
  Main.bridgeDeck
  Main.checkGameStatus
  Main.checkPlayerScore
  Main.continueRoundWithCurrentPlayer
  Main.continueRoundWithNextPlayer
  Main.createPlayers
  Main.cutDeck
  Main.dealCard
  Main.deck
  Main.determineWinner
  Main.dropPlayer
  Main.endGame
  Main.endProgram
  Main.endRound
  Main.firstHand
  Main.getPlayerScore
  Main.main
  Main.makeDeck
  Main.ranks
  Main.scoreAllPlayers
  Main.scoreCard
  Main.scorePlayer
  Main.setupGame
  Main.showPlayerCards
  Main.showPlayerScore
  Main.shuffle
  Main.shuffleDeck
  Main.shuffleDeck'
  Main.startGame
  Main.suits
module dependencies: GameTypes
package dependencies: Win32-2.6.1.0 array-0.5.3.0 base-4.12.0.0*
                      deepseq-1.4.4.0 ghc-prim-0.5.3 integer-gmp-1.0.2.0 random-1.1*
                      time-1.8.0.2
orphans: time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.12.0.0:GHC.Float
         base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
import  -/  base-4.12.0.0:Data.Foldable 6673f41a7644ecd4dda455d741d47ef8
import  -/  base-4.12.0.0:Data.List ccb3c44b4e7df281b8508bfc1f389d8d
import  -/  base-4.12.0.0:Data.OldList cd51cf46346202f55e4ecde7f0f7b58e
import  -/  base-4.12.0.0:Data.Tuple ddbd97abaf9b62e84e82a5bae338d270
import  -/  base-4.12.0.0:GHC.Base 954f4c258d193fab7048a63bfeb56dcf
import  -/  base-4.12.0.0:GHC.List 63f1dc438c14c2ecfce50219fbb7ff35
import  -/  base-4.12.0.0:GHC.Num 009f4fca9200daff9e3ffbe2d7676a2f
import  -/  base-4.12.0.0:GHC.Real 2becc15d35863665b039224a7445f8b0
import  -/  base-4.12.0.0:GHC.Show 48dce8b8129312101170e57c24f3ecbd
import  -/  base-4.12.0.0:Prelude aea9afd24db8aed3563d7d850ea453c0
import  -/  base-4.12.0.0:System.Exit a9a516a6f7156d1805324e8ca40bf315
import  -/  base-4.12.0.0:System.IO ef7039badfa76f34317e352d4f124933
import  -/  base-4.12.0.0:Text.Read e7452753e4b5b609f2d5caebdb00e722
import  -/  ghc-prim-0.5.3:GHC.Classes 6002495dc43e58d28c87e5e5e058752a
import  -/  ghc-prim-0.5.3:GHC.Types 57064c9f957b09bc2e360061ad5cae0b
import  -/  integer-gmp-1.0.2.0:GHC.Integer.Type 34234e515bc4cbda6d7cda923884fd3f
import  -/  GameTypes 3f6d9af0e75c13797764bd61b26d7233
  exports: d0cfcd50ba0ec194499f629b661e84f4
  Ace 52657e73d7d3a148b4d7874f69732d00
  Card 53aa120e8bda0e36d71124dff7e413f2
  Card a8e6ae55fd67c3708fd7e810811aa74c
  Club 48c7e885560245b470508896bf619bb2
  Deck 5fcf2c22612a7cad4f7d6e887392c0b3
  Deck 96fdc6884b8f6c17d30f907111d27fd4
  Diamond 90e3a2532f3da5d97419ba8737e8ef86
  Eight 31b17d890cae70baefe6c72c06460387
  Five 28e767a48672ffde8dd2e4266053a97b
  Four fd193ea3f5353d6fbc14f1b3c7a5f76d
  Game a06bafd2ffb458968cf7f1709c1bbf99
  Game 3bce3074357214c65a171812000654b7
  Hand fb158e1dd79474cb6bc6571b5ed82bac
  Heart 1fc6e533fb2279799ec4d09ed93ded4f
  Id a797aeaff508cea35068e953c1207cac
  Jack b0516b00cd5b3cc9a86480afb5913c90
  King 972fe00e8411f8a39d0bdff1c62b471c
  Nine 15938efffa7bc00201530f59a32e40b2
  Player 99ad26c60237c8cdcd314f906a7664f7
  Player 1ebe2b600e107f45149573fcae7cfe3f
  Queen 0cd3f8923def08e588a3ef3ffda1f166
  Rank 9d82380a3c4835adca6131728c7ceaf9
  Score aee40ddf141d35912419bc402b0cc0b9
  Seven 02ad61fd46045fd4df0976aec6e64a33
  Six 230294c4865bd499c6025f7b33225504
  Spade dff612f9017ee9becc8054d6beb53f11
  Suit 5c027ad0dfa3cc5f2e1f8cd5b82c6b02
  Ten 6956e95545e63199d81954710e74f5ad
  Three bfb9b28cffb8f7871eba6e705e143999
  Two dcab1bab61f752409b7e46ec101a3abc
import  -/  random-1.1:System.Random 2df3d2176d852a42a0e8aa97126009b4
be86c9d078d3acbf19ba91fe74a24273
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Main.$trModule3 Main.$trModule1) -}
b09d86f2c49dd5176b544d8d13ddb6c5
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule2) -}
e5875966b74dad2d29772660b8a75e33
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Main"#) -}
23b03bd7d075a00f5ad1ee10e6add7b8
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule4) -}
d026be77cb9ced20e35a61514e0458aa
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
06934a2fc590784645efc47883035ea1
  $wbeginRound ::
    GameTypes.Deck
    -> [GHC.Maybe.Maybe GameTypes.Player]
    -> GameTypes.Id
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GameTypes.Game #)
  {- Arity: 4, Strictness: <L,U(U)><L,U><L,U><S,U>, Inline: [2] -}
cd2e9c76ab4f23117f3f14deb1da5f3f
  $wcheckGameStatus ::
    GameTypes.Deck
    -> [GHC.Maybe.Maybe GameTypes.Player]
    -> GameTypes.Id
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GameTypes.Game #)
  {- Arity: 4, Strictness: <L,U(U)><S,U><S,U><S,U>, Inline: [2],
     Unfolding: (\ (ww :: GameTypes.Deck)
                   (ww1 :: [GHC.Maybe.Maybe GameTypes.Player])
                   (w :: GameTypes.Id)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.List.$wlenAcc
                        @ (GHC.Maybe.Maybe GameTypes.Player)
                        ww1
                        0# of ww2 { DEFAULT ->
                 case GHC.Integer.Type.gtInteger#
                        w
                        (GHC.Integer.Type.smallInteger ww2) of wild {
                   DEFAULT -> Main.$wbeginRound ww ww1 w w1
                   1#
                   -> case (GHC.IO.Handle.Text.hPutStr'
                              GHC.IO.Handle.FD.stdout
                              (case ww1 of wild1 {
                                 [] -> case Main.checkGameStatus2 ret_ty GHC.Base.String of {}
                                 : player players
                                 -> Main.announceWinner (Main.checkGameStatus_go players) })
                              GHC.Types.True)
                             `cast`
                           (GHC.Types.N:IO[0] <()>_R)
                             w1 of ds1 { (#,#) ipv ipv1 ->
                      (# ipv, GameTypes.Game ww ww1 #) } } }) -}
0f8fb2b9bd77da893cfa649de54c894a
  $wcheckPlayerScore ::
    [GHC.Maybe.Maybe GameTypes.Player]
    -> GameTypes.Id -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>, Inline: [2],
     Unfolding: (\ (ww :: [GHC.Maybe.Maybe GameTypes.Player])
                   (w :: GameTypes.Id) ->
                 case ww of wild {
                   [] -> GHC.Types.False
                   : y ys
                   -> case y of wild1 {
                        GHC.Maybe.Nothing -> GHC.Types.False
                        GHC.Maybe.Just ds
                        -> case ds of wild2 { GameTypes.Player i ds1 s ->
                           case GHC.Integer.Type.eqInteger# i w of wild3 {
                             DEFAULT -> GHC.Types.False
                             1#
                             -> case GHC.Integer.Type.gtInteger#
                                       s
                                       Main.checkPlayerScore1 of wild4 { DEFAULT ->
                                GHC.Prim.tagToEnum# @ GHC.Types.Bool wild4 } } } } }) -}
ed258b1585edd1fa81b259f50f3a72ad
  $wcontinueRoundWithCurrentPlayer ::
    GameTypes.Deck
    -> [GHC.Maybe.Maybe GameTypes.Player]
    -> GameTypes.Id
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GameTypes.Game #)
  {- Arity: 4, Strictness: <L,U(U)><L,U><L,U><S,U>, Inline: [2],
     Unfolding: (\ (ww :: GameTypes.Deck)
                   (ww1 :: [GHC.Maybe.Maybe GameTypes.Player])
                   (w :: GameTypes.Id)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (GHC.IO.Handle.Text.hPutStr'
                         GHC.IO.Handle.FD.stdout
                         Main.continueRoundWithCurrentPlayer6
                         GHC.Types.True)
                        `cast`
                      (GHC.Types.N:IO[0] <()>_R)
                        w1 of ds1 { (#,#) ipv ipv1 ->
                 case (GHC.IO.Handle.Text.hPutStr'
                         GHC.IO.Handle.FD.stdout
                         Main.continueRoundWithCurrentPlayer4
                         GHC.Types.True)
                        `cast`
                      (GHC.Types.N:IO[0] <()>_R)
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case GHC.IO.Handle.Internals.wantReadableHandle_1
                        @ GHC.Base.String
                        GHC.IO.Handle.Text.hGetLine4
                        GHC.IO.Handle.FD.stdin
                        GHC.IO.Handle.Text.hGetLine2
                          `cast`
                        (<GHC.IO.Handle.Types.Handle__>_R
                         ->_R Sym (GHC.Types.N:IO[0] <GHC.Base.String>_R))
                        ipv2 of ds3 { (#,#) ipv4 ipv5 ->
                 case ipv5 of wild {
                   [] -> Main.$wbeginRound ww ww1 w ipv4
                   : ds ds4
                   -> case ds of wild1 { GHC.Types.C# ds5 ->
                      case ds5 of ds6 {
                        DEFAULT -> Main.$wbeginRound ww ww1 w ipv4
                        'H'#
                        -> case ds4 of wild2 {
                             []
                             -> case ww of ww2 { GameTypes.Deck ww3 ->
                                case Main.$wdealCard ww3 ww1 w of ww4 { (#,#) ww5 ww6 ->
                                Main.$wbeginRound
                                  ww5
                                  (GHC.Base.map
                                     @ (GHC.Maybe.Maybe GameTypes.Player)
                                     @ (GHC.Maybe.Maybe GameTypes.Player)
                                     Main.continueRoundWithCurrentPlayer3
                                     ww6)
                                  w
                                  ipv4 } }
                             : ipv6 ipv7 -> Main.$wbeginRound ww ww1 w ipv4 }
                        'S'#
                        -> case ds4 of wild2 {
                             []
                             -> Main.$wcheckGameStatus
                                  ww
                                  ww1
                                  (GHC.Integer.Type.plusInteger
                                     w
                                     Main.continueRoundWithCurrentPlayer2)
                                  ipv4
                             : ipv6 ipv7 -> Main.$wbeginRound ww ww1 w ipv4 } } } } } } }) -}
b918a41946f305e8b1098cc9e37e09d9
  $wdealCard ::
    [GameTypes.Card]
    -> [GHC.Maybe.Maybe GameTypes.Player]
    -> GameTypes.Id
    -> (# GameTypes.Deck, [GHC.Maybe.Maybe GameTypes.Player] #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,1*U><L,U>,
     Inline: [2],
     Unfolding: (\ (ww :: [GameTypes.Card])
                   (ww1 :: [GHC.Maybe.Maybe GameTypes.Player])
                   (w :: GameTypes.Id) ->
                 (# GameTypes.Deck (Main.$wunsafeDrop @ GameTypes.Card 1# ww),
                    GHC.Base.map
                      @ (GHC.Maybe.Maybe GameTypes.Player)
                      @ (GHC.Maybe.Maybe GameTypes.Player)
                      (\ (m :: GHC.Maybe.Maybe GameTypes.Player) ->
                       case m of wild {
                         GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ GameTypes.Player
                         GHC.Maybe.Just p
                         -> case p of wild1 { GameTypes.Player x ds s ->
                            case ds of wild2 { GameTypes.Hand h ->
                            case GHC.Integer.Type.eqInteger# x w of wild3 {
                              DEFAULT -> wild
                              1#
                              -> GHC.Maybe.Just
                                   @ GameTypes.Player
                                   (GameTypes.Player
                                      x
                                      (GameTypes.Hand
                                         (letrec {
                                            $wgo2 :: [GameTypes.Card]
                                                     -> GHC.Prim.Int# -> [GameTypes.Card]
                                              {- Arity: 2, Strictness: <S,1*U><L,1*U>,
                                                 Inline: [2] -}
                                            = \ (w1 :: [GameTypes.Card]) (ww2 :: GHC.Prim.Int#) ->
                                              case w1 of wild4 {
                                                [] -> h
                                                : y ys
                                                -> case ww2 of ds1 {
                                                     DEFAULT
                                                     -> GHC.Types.:
                                                          @ GameTypes.Card
                                                          y
                                                          ($wgo2 ys (GHC.Prim.-# ds1 1#))
                                                     1# -> GHC.Types.: @ GameTypes.Card y h } }
                                          } in
                                          $wgo2 ww 1#))
                                      s) } } } })
                      ww1 #)) -}
13de0242ad460bd304b0cb5ba118ac0e
  $wdetermineWinner ::
    [GHC.Maybe.Maybe GameTypes.Player]
    -> GHC.Maybe.Maybe (GameTypes.Id, GameTypes.Score)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2],
     Unfolding: (\ (ww :: [GHC.Maybe.Maybe GameTypes.Player]) ->
                 case ww of wild {
                   [] -> Main.checkGameStatus2
                   : player players -> Main.determineWinner_go players }) -}
37598adaa63b750fc669a094c610c367
  $wendGame ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U>, Inline: [2],
     Unfolding: (\ (w :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (GHC.IO.Handle.Text.hPutStr'
                         GHC.IO.Handle.FD.stdout
                         Main.endGame6
                         GHC.Types.True)
                        `cast`
                      (GHC.Types.N:IO[0] <()>_R)
                        w of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Internals.wantReadableHandle_1
                        @ GHC.Base.String
                        GHC.IO.Handle.Text.hGetLine4
                        GHC.IO.Handle.FD.stdin
                        GHC.IO.Handle.Text.hGetLine2
                          `cast`
                        (<GHC.IO.Handle.Types.Handle__>_R
                         ->_R Sym (GHC.Types.N:IO[0] <GHC.Base.String>_R))
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case ipv3 of wild {
                   []
                   -> case Main.endGame5
                      ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                      of {}
                   : ds ds3
                   -> case ds of wild1 { GHC.Types.C# ds4 ->
                      case ds4 of ds5 {
                        DEFAULT
                        -> case Main.endGame5
                           ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                           of {}
                        'N'#
                        -> case ds3 of wild2 {
                             [] -> Main.endGame4 ipv2
                             : ipv4 ipv5
                             -> case Main.endGame5
                                ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                                of {} }
                        'Y'#
                        -> case ds3 of wild2 {
                             [] -> Main.endGame2 ipv2
                             : ipv4 ipv5
                             -> case Main.endGame5
                                ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                                of {} } } } } } }) -}
78161c185e8ebbcb19261315ee041172
  $wfirstHand ::
    GameTypes.Deck
    -> [GHC.Maybe.Maybe GameTypes.Player]
    -> (# GameTypes.Deck, [GHC.Maybe.Maybe GameTypes.Player] #)
  {- Arity: 2, Strictness: <L,U(U)><S,U>, Inline: [2],
     Unfolding: (\ (ww :: GameTypes.Deck)
                   (ww1 :: [GHC.Maybe.Maybe GameTypes.Player]) ->
                 case GHC.List.$wlenAcc
                        @ (GHC.Maybe.Maybe GameTypes.Player)
                        ww1
                        0# of ww2 { DEFAULT ->
                 let {
                   c :: GHC.Integer.Type.Integer = GHC.Integer.Type.smallInteger ww2
                 } in
                 case Main.$wgo1 ww ww1 c of ww3 { (#,#) ww4 ww5 ->
                 Main.$wgo1 ww4 ww5 c } }) -}
ca6a6392083d4eba118f71924b05fe1c
  $wgetPlayerScore ::
    [GHC.Maybe.Maybe GameTypes.Player]
    -> GameTypes.Id -> GHC.Maybe.Maybe GameTypes.Score
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>, Inline: [2],
     Unfolding: (\ (ww :: [GHC.Maybe.Maybe GameTypes.Player])
                   (w :: GameTypes.Id) ->
                 case ww of wild {
                   [] -> GHC.Maybe.Nothing @ GameTypes.Score
                   : y ys
                   -> case y of wild1 {
                        GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ GameTypes.Score
                        GHC.Maybe.Just ds
                        -> case ds of wild2 { GameTypes.Player i ds1 s ->
                           case GHC.Integer.Type.eqInteger# i w of wild3 {
                             DEFAULT -> GHC.Maybe.Nothing @ GameTypes.Score
                             1# -> GHC.Maybe.Just @ GameTypes.Score s } } } }) -}
8d02bb50ae4b1e37832cbd89a6d6addd
  $wgo ::
    [GameTypes.Card]
    -> [GameTypes.Card] -> (# [GameTypes.Card], [GameTypes.Card] #)
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [2] -}
08ad3a977033f7e10cb89a8bbb82b1b0
  $wgo1 ::
    GameTypes.Deck
    -> [GHC.Maybe.Maybe GameTypes.Player]
    -> GHC.Integer.Type.Integer
    -> (# GameTypes.Deck, [GHC.Maybe.Maybe GameTypes.Player] #)
  {- Arity: 3, Strictness: <L,U(U)><L,U><S,U>, Inline: [2] -}
72c3ba79dd3217376c84715f78ff6499
  $wmakeDeck ::
    [GameTypes.Suit] -> [GameTypes.Rank] -> (# [GameTypes.Card] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><L,U>, Inline: [2],
     Unfolding: (\ (w :: [GameTypes.Suit]) (w1 :: [GameTypes.Rank]) ->
                 (# letrec {
                      go :: [GameTypes.Suit] -> [GameTypes.Card]
                        {- Arity: 1, Strictness: <S,1*U> -}
                      = \ (ds :: [GameTypes.Suit]) ->
                        case ds of wild {
                          [] -> GHC.Types.[] @ GameTypes.Card
                          : y ys
                          -> let {
                               z :: [GameTypes.Card] = go ys
                             } in
                             letrec {
                               go1 :: [GameTypes.Rank] -> [GameTypes.Card]
                                 {- Arity: 1, Strictness: <S,1*U> -}
                               = \ (ds1 :: [GameTypes.Rank]) ->
                                 case ds1 of wild1 {
                                   [] -> z
                                   : y1 ys1
                                   -> GHC.Types.: @ GameTypes.Card (GameTypes.Card y y1) (go1 ys1) }
                             } in
                             go1 w1 }
                    } in
                    go w #)) -}
f6fb3844b22ac99aadb01f58856980a8
  $wshowPlayerCards ::
    [GHC.Maybe.Maybe GameTypes.Player]
    -> GameTypes.Id -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [2],
     Unfolding: (\ (ww :: [GHC.Maybe.Maybe GameTypes.Player])
                   (w :: GameTypes.Id) ->
                 letrec {
                   go :: [GHC.Maybe.Maybe GameTypes.Player] -> [GHC.Types.Char]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [GHC.Maybe.Maybe GameTypes.Player]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ GHC.Types.Char
                       : y ys
                       -> case y of wild1 {
                            GHC.Maybe.Nothing -> go ys
                            GHC.Maybe.Just ds1
                            -> case ds1 of wild2 { GameTypes.Player i ds2 ds3 ->
                               case ds2 of wild3 { GameTypes.Hand cs ->
                               case GHC.Integer.Type.eqInteger# i w of wild4 {
                                 DEFAULT -> go ys
                                 1#
                                 -> case Main.showPlayerCards_go cs of wild5 {
                                      [] -> go ys
                                      : x xs1
                                      -> GHC.Base.++
                                           @ GHC.Types.Char
                                           (Data.OldList.intercalate1
                                              @ GHC.Types.Char
                                              (GHC.Types.:
                                                 @ [GHC.Types.Char]
                                                 x
                                                 (Data.OldList.prependToAll
                                                    @ [GHC.Types.Char]
                                                    Main.showPlayerCards1
                                                    xs1)))
                                           (go ys) } } } } } }
                 } in
                 go ww) -}
51116a80bcfd1767bddb955c3cd69be5
  $wshowPlayerScore ::
    [GHC.Maybe.Maybe GameTypes.Player]
    -> GameTypes.Id -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [2],
     Unfolding: (\ (ww :: [GHC.Maybe.Maybe GameTypes.Player])
                   (w :: GameTypes.Id) ->
                 letrec {
                   go :: [GHC.Maybe.Maybe GameTypes.Player] -> [GHC.Types.Char]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [GHC.Maybe.Maybe GameTypes.Player]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ GHC.Types.Char
                       : y ys
                       -> case y of wild1 {
                            GHC.Maybe.Nothing -> go ys
                            GHC.Maybe.Just ds1
                            -> case ds1 of wild2 { GameTypes.Player i ds2 s ->
                               case GHC.Integer.Type.eqInteger# i w of wild3 {
                                 DEFAULT -> go ys
                                 1#
                                 -> case GHC.Show.$w$cshowsPrec4
                                           0#
                                           s
                                           (GHC.Types.[] @ GHC.Types.Char) of ww2 { (#,#) ww3 ww4 ->
                                    GHC.Base.++
                                      @ GHC.Types.Char
                                      (GHC.Types.: @ GHC.Types.Char ww3 ww4)
                                      (go ys) } } } } }
                 } in
                 go ww) -}
afed77d2bb03e116a817eb281f967fc7
  $wshuffle ::
    [GameTypes.Card]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GameTypes.Deck #)
  {- Arity: 2, Strictness: <L,U><S,U>, Inline: [2],
     Unfolding: (\ (ww :: [GameTypes.Card])
                   (w :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.Random.$fRandomInt3
                        (Main.setupGame3,
                         case GHC.List.$wlenAcc @ GameTypes.Card ww 0# of ww2 { DEFAULT ->
                         GHC.Types.I# (GHC.Prim.-# ww2 1#) })
                        w of ds1 { (#,#) ipv ipv1 ->
                 (# ipv,
                    case ipv1 of wild { GHC.Types.I# x ->
                    case GHC.Prim.<=# x 0# of lwild {
                      DEFAULT
                      -> case GHC.List.$wsplitAt'
                                @ GameTypes.Card
                                wild
                                ww of ww1 { (#,#) ww2 ww3 ->
                         case Main.$wgo ww2 ww3 of ww4 { (#,#) ww5 ww6 ->
                         GameTypes.Deck
                           (Main.bridgeDeck_go
                              (Data.OldList.transpose
                                 @ GameTypes.Card
                                 (GHC.Types.:
                                    @ [GameTypes.Card]
                                    ww5
                                    (GHC.Types.:
                                       @ [GameTypes.Card]
                                       ww6
                                       (GHC.Types.[] @ [GameTypes.Card]))))) } }
                      1#
                      -> case Main.$wgo
                                (GHC.Types.[] @ GameTypes.Card)
                                ww of ww1 { (#,#) ww2 ww3 ->
                         GameTypes.Deck
                           (Main.bridgeDeck_go
                              (Data.OldList.transpose
                                 @ GameTypes.Card
                                 (GHC.Types.:
                                    @ [GameTypes.Card]
                                    ww2
                                    (GHC.Types.:
                                       @ [GameTypes.Card]
                                       ww3
                                       (GHC.Types.[] @ [GameTypes.Card]))))) } } } #) }) -}
ff3331105c1a0a4bdcdbbe6bdb662f9a
  $wshuffleDeck' ::
    GHC.Prim.Int#
    -> GHC.Types.IO GameTypes.Deck -> GHC.Types.IO GameTypes.Deck
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [2] -}
cd46e1e74ee86a6e957b7b0c0f0c686c
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [2] -}
e10c999369956cf9211a028b0af44b16
  announceWinner ::
    GHC.Maybe.Maybe (GameTypes.Id, GameTypes.Score) -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (m :: GHC.Maybe.Maybe
                           (GameTypes.Id, GameTypes.Score)) ->
                 case m of wild {
                   GHC.Maybe.Nothing -> Main.announceWinner5
                   GHC.Maybe.Just ds
                   -> case ds of wild1 { (,) id score ->
                      GHC.CString.unpackAppendCString#
                        Main.announceWinner4
                        (case GHC.Show.$w$cshowsPrec4
                                0#
                                id
                                (GHC.Types.[] @ GHC.Types.Char) of ww2 { (#,#) ww3 ww4 ->
                         GHC.Base.++
                           @ GHC.Types.Char
                           (GHC.Types.: @ GHC.Types.Char ww3 ww4)
                           (GHC.CString.unpackAppendCString#
                              Main.announceWinner3
                              (case GHC.Show.$w$cshowsPrec4
                                      0#
                                      score
                                      (GHC.Types.[] @ GHC.Types.Char) of ww1 { (#,#) ww5 ww6 ->
                               GHC.Base.++
                                 @ GHC.Types.Char
                                 (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                                 Main.announceWinner1 })) }) } }) -}
b8406f8a237b8cbc085104ebbea6a4d2
  announceWinner1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.announceWinner2) -}
c071196eb35bbe54e6a437756dbe1c3d
  announceWinner2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" points!"#) -}
11f7bc56e68d964c799bbd6b34d856f8
  announceWinner3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" with a score of "#) -}
6e0efa747cb912c9e69aead4a7a67ab3
  announceWinner4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("The winner is Player "#) -}
141ed304bc6480c6ae8ae1abb7c2a1c4
  announceWinner5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.announceWinner6) -}
12883593af7717b7858ec107f4b63267
  announceWinner6 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("I'm sorry, I guess you are all losers"#) -}
8e099f681a8b4bce5cb2673f20c9d8f7
  beginRound ::
    GameTypes.Game -> GameTypes.Id -> GHC.Types.IO GameTypes.Game
  {- Arity: 3, Strictness: <S,1*U(U(U),U)><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.beginRound1
                  `cast`
                (<GameTypes.Game>_R
                 ->_R <GameTypes.Id>_R
                 ->_R Sym (GHC.Types.N:IO[0] <GameTypes.Game>_R)) -}
e9ddfed182aad033de8e7c339dcbc863
  beginRound1 ::
    GameTypes.Game
    -> GameTypes.Id
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GameTypes.Game #)
  {- Arity: 3, Strictness: <S,1*U(U(U),U)><L,U><S,U>, Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GameTypes.Game)
                   (w1 :: GameTypes.Id)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 Main.$wbeginRound ww1 ww2 w1 w2 }) -}
3876c3627502ae9077cc7ccfa5f9534a
  bridgeDeck ::
    ([GameTypes.Card], [GameTypes.Card]) -> GameTypes.Deck
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U)>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: ([GameTypes.Card], [GameTypes.Card])) ->
                 case w of ww { (,) ww1 ww2 ->
                 GameTypes.Deck
                   (Main.bridgeDeck_go
                      (Data.OldList.transpose
                         @ GameTypes.Card
                         (GHC.Types.:
                            @ [GameTypes.Card]
                            ww1
                            (GHC.Types.:
                               @ [GameTypes.Card]
                               ww2
                               (GHC.Types.[] @ [GameTypes.Card]))))) }) -}
539cb4b1260c3811b5eb4defe5873ad0
  bridgeDeck_go :: [[GameTypes.Card]] -> [GameTypes.Card]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
cbbbc8d4d77d391b4dfd3efd6c14055d
  checkGameStatus ::
    GameTypes.Game -> GameTypes.Id -> GHC.Types.IO GameTypes.Game
  {- Arity: 3, Strictness: <S(LS),1*U(U(U),U)><S,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.checkGameStatus1
                  `cast`
                (<GameTypes.Game>_R
                 ->_R <GameTypes.Id>_R
                 ->_R Sym (GHC.Types.N:IO[0] <GameTypes.Game>_R)) -}
a7594b37370d0bceb39d623b8b0cc94c
  checkGameStatus1 ::
    GameTypes.Game
    -> GameTypes.Id
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GameTypes.Game #)
  {- Arity: 3, Strictness: <S(LS),1*U(U(U),U)><S,U><S,U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GameTypes.Game)
                   (w1 :: GameTypes.Id)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 Main.$wcheckGameStatus ww1 ww2 w1 w2 }) -}
66021606b5631da8fac7d6089be70f19
  checkGameStatus2 :: GHC.Maybe.Maybe (GameTypes.Id, GameTypes.Score)
  {- Strictness: x -}
30a59cc6d21debaf514fff2adb25915a
  checkGameStatus_go ::
    [GHC.Maybe.Maybe GameTypes.Player]
    -> GHC.Maybe.Maybe (GameTypes.Id, GameTypes.Score)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
7bdca29b904c695fedb4b4e799ebd50e
  checkPlayerScore ::
    GameTypes.Game -> GameTypes.Id -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)><L,1*U>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GameTypes.Game) (w1 :: GameTypes.Id) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 Main.$wcheckPlayerScore ww2 w1 }) -}
7777e971573710c38b2a02ddacb6294c
  checkPlayerScore1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (21) -}
ee627b0f710b47d72ecf0b32fdb7d629
  continueRoundWithCurrentPlayer ::
    GameTypes.Game -> GameTypes.Id -> GHC.Types.IO GameTypes.Game
  {- Arity: 3, Strictness: <S,1*U(U(U),U)><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.continueRoundWithCurrentPlayer1
                  `cast`
                (<GameTypes.Game>_R
                 ->_R <GameTypes.Id>_R
                 ->_R Sym (GHC.Types.N:IO[0] <GameTypes.Game>_R)) -}
a2284bbcced8de91649f11ed1be749ee
  continueRoundWithCurrentPlayer1 ::
    GameTypes.Game
    -> GameTypes.Id
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GameTypes.Game #)
  {- Arity: 3, Strictness: <S,1*U(U(U),U)><L,U><S,U>, Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GameTypes.Game)
                   (w1 :: GameTypes.Id)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 Main.$wcontinueRoundWithCurrentPlayer ww1 ww2 w1 w2 }) -}
2b37268fd0abe6f2218172c8e753c8f8
  continueRoundWithCurrentPlayer2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
f1224ec39c273b078793217827fc4955
  continueRoundWithCurrentPlayer3 ::
    GHC.Maybe.Maybe GameTypes.Player
    -> GHC.Maybe.Maybe GameTypes.Player
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: GHC.Maybe.Maybe GameTypes.Player) ->
                 case ds1 of wild {
                   GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ GameTypes.Player
                   GHC.Maybe.Just a1
                   -> GHC.Maybe.Just @ GameTypes.Player (Main.scorePlayer a1) }) -}
0b31ec92e07e2a6e09e5731172ebf0a7
  continueRoundWithCurrentPlayer4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Main.continueRoundWithCurrentPlayer5) -}
652ff9243add849d27059d59941ed229
  continueRoundWithCurrentPlayer5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("(H)it or (S)tand?"#) -}
36441a4c2fd0b7949bd1280414992071
  continueRoundWithCurrentPlayer6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Main.continueRoundWithCurrentPlayer7) -}
858531662e3d5e047b0ffb90d1f70fb4
  continueRoundWithCurrentPlayer7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("What would you like to do --"#) -}
56a558371d5170e91712a2ee69e511b2
  continueRoundWithNextPlayer ::
    GameTypes.Game -> GameTypes.Id -> GHC.Types.IO GameTypes.Game
  {- Arity: 3, Strictness: <L,1*U(U(U),1*U)><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.continueRoundWithNextPlayer1
                  `cast`
                (<GameTypes.Game>_R
                 ->_R <GameTypes.Id>_R
                 ->_R Sym (GHC.Types.N:IO[0] <GameTypes.Game>_R)) -}
1d3ae3e0f1d29c26b1c064d336e7f5b5
  continueRoundWithNextPlayer1 ::
    GameTypes.Game
    -> GameTypes.Id
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GameTypes.Game #)
  {- Arity: 3, Strictness: <L,1*U(U(U),1*U)><L,U><S,U>,
     Unfolding: (\ (game :: GameTypes.Game)
                   (id :: GameTypes.Id)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (GHC.IO.Handle.Text.hPutStr'
                         GHC.IO.Handle.FD.stdout
                         Main.continueRoundWithNextPlayer2
                         GHC.Types.True)
                        `cast`
                      (GHC.Types.N:IO[0] <()>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case game of ww { GameTypes.Game ww1 ww2 ->
                 letrec {
                   go :: [GHC.Maybe.Maybe GameTypes.Player]
                         -> [GHC.Maybe.Maybe GameTypes.Player]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [GHC.Maybe.Maybe GameTypes.Player]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ (GHC.Maybe.Maybe GameTypes.Player)
                       : y ys
                       -> GHC.Types.:
                            @ (GHC.Maybe.Maybe GameTypes.Player)
                            (case y of wild1 {
                               GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ GameTypes.Player
                               GHC.Maybe.Just p
                               -> case p of wild2 { GameTypes.Player i ds2 ds3 ->
                                  case GHC.Integer.Type.eqInteger# i id of wild3 {
                                    DEFAULT -> wild1
                                    1# -> GHC.Maybe.Nothing @ GameTypes.Player } } })
                            (go ys) }
                 } in
                 Main.$wcheckGameStatus
                   ww1
                   (go ww2)
                   (GHC.Integer.Type.plusInteger
                      id
                      Main.continueRoundWithCurrentPlayer2)
                   ipv } }) -}
46710fcbd9683e607321cb9f8dbc1f1d
  continueRoundWithNextPlayer2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Main.continueRoundWithNextPlayer3) -}
f4151ca83b8b8ad2c0ad81bb3d48a2cb
  continueRoundWithNextPlayer3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Sorry, you went over 21"#) -}
4c525a56583ef35594c05d8d20b8e9bb
  createPlayers ::
    GHC.Integer.Type.Integer -> [GHC.Maybe.Maybe GameTypes.Player]
  {- Arity: 1, Strictness: <S,U> -}
172d936656d027437113ee958d2f98f5
  cutDeck ::
    GHC.Types.Int
    -> GameTypes.Deck -> ([GameTypes.Card], [GameTypes.Card])
  {- Arity: 2, Strictness: <S(S),1*U(U)><S(S),1*U(1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (index :: GHC.Types.Int) (ds :: GameTypes.Deck) ->
                 case ds of wild { GameTypes.Deck d ->
                 case index of wild1 { GHC.Types.I# x ->
                 case GHC.Prim.<=# x 0# of lwild {
                   DEFAULT
                   -> Main.cutDeck_go
                        (GHC.List.splitAt_splitAt' @ GameTypes.Card wild1 d)
                   1# -> Main.cutDeck_go (GHC.Types.[] @ GameTypes.Card, d) } } }) -}
59c62c1dc103db0bbf6a49cdb6f9c0a8
  cutDeck_go ::
    ([GameTypes.Card], [GameTypes.Card])
    -> ([GameTypes.Card], [GameTypes.Card])
  {- Arity: 1, Strictness: <S(SS),1*U(1*U,1*U)>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: ([GameTypes.Card], [GameTypes.Card])) ->
                 case w of ww { (,) ww1 ww2 ->
                 case Main.$wgo ww1 ww2 of ww3 { (#,#) ww4 ww5 -> (ww4, ww5) } }) -}
c4adf2d35a41d1cac39c9b7535e0b42a
  dealCard :: GameTypes.Game -> GameTypes.Id -> GameTypes.Game
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U(U),1*U)><L,U>m, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GameTypes.Game) (w1 :: GameTypes.Id) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 case ww1 of ww3 { GameTypes.Deck ww4 ->
                 case Main.$wdealCard ww4 ww2 w1 of ww5 { (#,#) ww6 ww7 ->
                 GameTypes.Game ww6 ww7 } } }) -}
2347e238f1fc7785497ceee07291aa6e
  deck :: GameTypes.Deck
  {- Unfolding: (case Main.$wmakeDeck
                        Main.suits
                        Main.ranks of ww { Unit# ww1 ->
                 GameTypes.Deck ww1 }) -}
77e48ab09b20666057dbffc26e349baf
  determineWinner ::
    GameTypes.Game -> GHC.Maybe.Maybe (GameTypes.Id, GameTypes.Score)
  {- Arity: 1, Strictness: <S(LS),1*U(A,1*U)>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GameTypes.Game) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 Main.$wdetermineWinner ww2 }) -}
64850f187c4d2c7f162192e298108d38
  determineWinner_go ::
    [GHC.Maybe.Maybe GameTypes.Player]
    -> GHC.Maybe.Maybe (GameTypes.Id, GameTypes.Score)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
d34e9ca03bead185bf37723446d3c7bd
  dropPlayer :: GameTypes.Game -> GameTypes.Id -> GameTypes.Game
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U,1*U)><L,U>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GameTypes.Game) (w1 :: GameTypes.Id) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 GameTypes.Game
                   ww1
                   (GHC.Base.build
                      @ (GHC.Maybe.Maybe GameTypes.Player)
                      (\ @ b1
                         (c :: GHC.Maybe.Maybe GameTypes.Player -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ (GHC.Maybe.Maybe GameTypes.Player)
                         @ b1
                         (GHC.Base.mapFB
                            @ (GHC.Maybe.Maybe GameTypes.Player)
                            @ b1
                            @ (GHC.Maybe.Maybe GameTypes.Player)
                            c
                            (\ (m :: GHC.Maybe.Maybe GameTypes.Player) ->
                             case m of wild {
                               GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ GameTypes.Player
                               GHC.Maybe.Just p
                               -> case p of wild1 { GameTypes.Player i ds ds1 ->
                                  case GHC.Integer.Type.eqInteger# i w1 of wild2 {
                                    DEFAULT -> GHC.Maybe.Just @ GameTypes.Player wild1
                                    1# -> GHC.Maybe.Nothing @ GameTypes.Player } } }))
                         n
                         ww2)) }) -}
917c340ee5166dc03172bc61a8e690f2
  endGame :: GHC.Types.IO GameTypes.Game -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,A><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.endGame1
                  `cast`
                (<GHC.Types.IO GameTypes.Game>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
6cd425619ad31d9c91384e1ded085d50
  endGame1 ::
    GHC.Types.IO GameTypes.Game
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,A><S,U>, Inline: [2],
     Unfolding: InlineRule (2, True, True)
                (\ (w :: GHC.Types.IO GameTypes.Game)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 Main.$wendGame w1) -}
0f6ea1c11cf388856ab68f9f6c59e83f
  endGame2 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case Main.endGame3 s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of ww { GameTypes.Game ww1 ww2 ->
                 case Main.$wbeginRound
                        ww1
                        ww2
                        Main.continueRoundWithCurrentPlayer2
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 (# ipv2, GHC.Tuple.() #) } } }) -}
560c2bf23cc508b7d2b1c17ea0a69158
  endGame3 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GameTypes.Game #)
  {- Arity: 1, Strictness: <S,U> -}
89a63fc72da54db12cc52f3b6a21a2f5
  endGame4 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U> -}
adceda436a94a62dbe28bb3d278d2ce2
  endGame5 :: GHC.Types.IO ()
  {- Strictness: x -}
e383d64923ce3d7e6da9d817951abbdd
  endGame6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.endGame7) -}
0e537dee12cbcfc7299d770111516f3c
  endGame7 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Would you like to play again? (Y) (N)"#) -}
8f02615f614757167a3b12d173c1d8c0
  endProgram :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.endGame4 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
49491a07074cac70bbd7d68199323751
  endRound :: GameTypes.Game -> GHC.Types.IO GameTypes.Game
  {- Arity: 2, Strictness: <L,U(U,U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.endRound1
                  `cast`
                (<GameTypes.Game>_R
                 ->_R Sym (GHC.Types.N:IO[0] <GameTypes.Game>_R)) -}
eb43e489845c81ffc93e399755f5d519
  endRound1 ::
    GameTypes.Game
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GameTypes.Game #)
  {- Arity: 2, Strictness: <L,U(U,U)><S,U>,
     Unfolding: (\ (game :: GameTypes.Game)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (GHC.IO.Handle.Text.hPutStr'
                         GHC.IO.Handle.FD.stdout
                         (case game of wild { GameTypes.Game ds ds1 ->
                          case ds1 of wild1 {
                            [] -> case Main.checkGameStatus2 ret_ty GHC.Base.String of {}
                            : player players
                            -> Main.announceWinner (Main.determineWinner_go players) } })
                         GHC.Types.True)
                        `cast`
                      (GHC.Types.N:IO[0] <()>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 (# ipv, game #) }) -}
659d1431c58a9eedd6b3392c3ab7e4d1
  firstHand :: GameTypes.Game -> GameTypes.Game
  {- Arity: 1, Strictness: <S(LS),1*U(U(U),U)>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GameTypes.Game) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 case Main.$wfirstHand ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 GameTypes.Game ww4 ww5 } }) -}
74be7c0feaa1fbb5db9a7773e254072d
  getPlayerScore ::
    GameTypes.Game -> GameTypes.Id -> GHC.Maybe.Maybe GameTypes.Score
  {- Arity: 2, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)><L,1*U>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GameTypes.Game) (w1 :: GameTypes.Id) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 Main.$wgetPlayerScore ww2 w1 }) -}
3f0de3657c6fd2859d81577434bf46a8
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.endGame2 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
95b63a60a4fde0e411d267f078cbaa91
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.endGame2 `cast` (Sym (GHC.Types.N:IO[0] <()>_R))) -}
6a770963b78cbc4b2eb57d8025e6d1a2
  makeDeck :: [GameTypes.Suit] -> [GameTypes.Rank] -> GameTypes.Deck
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><L,U>m, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [GameTypes.Suit]) (w1 :: [GameTypes.Rank]) ->
                 case Main.$wmakeDeck w w1 of ww { Unit# ww1 ->
                 GameTypes.Deck ww1 }) -}
9d56dfd09f51ba5e3578ec0b3922e383
  ranks :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.Ace
                   Main.ranks1) -}
d3894721df81ca275062c885f6e2fcf1
  ranks1 :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.Two
                   Main.ranks2) -}
23933a7930889fd0b56e4de64e3b0d16
  ranks10 :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.Jack
                   Main.ranks11) -}
57a2a086b0e7d6adcdf321afb4120dfa
  ranks11 :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.Queen
                   Main.ranks12) -}
46917a10a9b789a8b24fbae35b142212
  ranks12 :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.King
                   (GHC.Types.[] @ GameTypes.Rank)) -}
1e1af0ef01515f644f3d908410ec600b
  ranks2 :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.Three
                   Main.ranks3) -}
5c5d3eadef064da78f7e738fe45ca567
  ranks3 :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.Four
                   Main.ranks4) -}
e85f0bf69c9e46e1d22a7210b1e0df44
  ranks4 :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.Five
                   Main.ranks5) -}
c13c82e7ea8884807cfa8f6cad372c61
  ranks5 :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.Six
                   Main.ranks6) -}
7f7dcf9c54c1159751e422c935b600b7
  ranks6 :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.Seven
                   Main.ranks7) -}
833d732c277f8d8352ede462981c9194
  ranks7 :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.Eight
                   Main.ranks8) -}
09964aa7bd2d8a28333b9bea50aa8da1
  ranks8 :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.Nine
                   Main.ranks9) -}
8982edb3d62208b0f267ac6c492c91d2
  ranks9 :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.Ten
                   Main.ranks10) -}
daacc58c3d9040df8e92cd75deffe250
  scoreAllPlayers :: GameTypes.Game -> GameTypes.Game
  {- Arity: 1, Strictness: <S,1*U(U,1*U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GameTypes.Game) ->
                 case ds of wild { GameTypes.Game deck1 players ->
                 GameTypes.Game
                   deck1
                   (GHC.Base.build
                      @ (GHC.Maybe.Maybe GameTypes.Player)
                      (\ @ b1
                         (c :: GHC.Maybe.Maybe GameTypes.Player -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ (GHC.Maybe.Maybe GameTypes.Player)
                         @ b1
                         (GHC.Base.mapFB
                            @ (GHC.Maybe.Maybe GameTypes.Player)
                            @ b1
                            @ (GHC.Maybe.Maybe GameTypes.Player)
                            c
                            Main.continueRoundWithCurrentPlayer3)
                         n
                         players)) }) -}
3deb8ffd4d29570e6d172a368d93951a
  scoreCard ::
    GameTypes.Card
    -> (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>m,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GameTypes.Card) ->
                 case w of ww { GameTypes.Card ww1 ww2 ->
                 case ww2 of wild {
                   DEFAULT -> (Main.scoreCard10, Main.scoreCard10)
                   GameTypes.Ace
                   -> (Main.continueRoundWithCurrentPlayer2, Main.scoreCard9)
                   GameTypes.Two -> (Main.scoreCard8, Main.scoreCard8)
                   GameTypes.Three -> (Main.scoreCard7, Main.scoreCard7)
                   GameTypes.Four -> (Main.scoreCard6, Main.scoreCard6)
                   GameTypes.Five -> (Main.scoreCard5, Main.scoreCard5)
                   GameTypes.Six -> (Main.scoreCard4, Main.scoreCard4)
                   GameTypes.Seven -> (Main.scoreCard3, Main.scoreCard3)
                   GameTypes.Eight -> (Main.scoreCard2, Main.scoreCard2)
                   GameTypes.Nine -> (Main.scoreCard1, Main.scoreCard1) } }) -}
68925f110c21cbe633ff3005226875d7
  scoreCard1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (9) -}
d05fb9c730c40c26ed9c6cb38a9ce5fd
  scoreCard10 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (10) -}
14ceebd89c6cbccd2c88911e28672a77
  scoreCard2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (8) -}
ea42f850158e636625147e6cd0287179
  scoreCard3 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (7) -}
cf8ff0ebee927005d41881e1f7266f98
  scoreCard4 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (6) -}
9c22a376c4bdb432b1b19dd09576cb3a
  scoreCard5 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (5) -}
8dead26e191b5f5d2db7b7f8c220344c
  scoreCard6 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (4) -}
fa5bba6be27da952bc65d0d126934b91
  scoreCard7 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (3) -}
c77e0d1ab48c6b560a3ff511f710b8ee
  scoreCard8 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (2) -}
5ca156c44f68f80f51823c4519320509
  scoreCard9 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (11) -}
d99f8522cefdbc5a934b9d216c95aaee
  scorePlayer :: GameTypes.Player -> GameTypes.Player
  {- Arity: 1, Strictness: <S(LSL),1*U(U,1*U(U),A)>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GameTypes.Player) ->
                 case w of ww { GameTypes.Player ww1 ww2 ww3 ->
                 case ww2 of ww4 { GameTypes.Hand ww5 ->
                 GameTypes.Player
                   ww1
                   (GameTypes.Hand ww5)
                   (let {
                      temp :: GHC.Integer.Type.Integer = Main.scorePlayer_go1 ww5
                    } in
                    case GHC.Integer.Type.gtInteger#
                           temp
                           Main.checkPlayerScore1 of wild {
                      DEFAULT -> temp 1# -> Main.scorePlayer_go ww5 }) } }) -}
423bd1feb5b3526f9ae83d42878b5f2d
  scorePlayer_go :: [GameTypes.Card] -> GHC.Integer.Type.Integer
  {- Arity: 1, Strictness: <S,1*U> -}
9ad6e85de7834aeb6e6e9da2743d2bb2
  scorePlayer_go1 :: [GameTypes.Card] -> GHC.Integer.Type.Integer
  {- Arity: 1, Strictness: <S,1*U> -}
c1da9185c33056c68392cfe7fb39c940
  setupGame ::
    GameTypes.Deck
    -> GHC.Integer.Type.Integer -> GHC.Types.IO GameTypes.Game
  {- Arity: 3, Strictness: <L,U(U)><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.setupGame1
                  `cast`
                (<GameTypes.Deck>_R
                 ->_R <GHC.Integer.Type.Integer>_R
                 ->_R Sym (GHC.Types.N:IO[0] <GameTypes.Game>_R)) -}
21b4e1bf839fce8d8074aea618a9e47c
  setupGame1 ::
    GameTypes.Deck
    -> GHC.Integer.Type.Integer
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GameTypes.Game #)
  {- Arity: 3, Strictness: <L,U(U)><L,U><S,U>,
     Unfolding: (\ (deck1 :: GameTypes.Deck)
                   (playerCount :: GHC.Integer.Type.Integer)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (Main.$wshuffleDeck'
                         10000#
                         (Main.setupGame2 deck1)
                           `cast`
                         (Sym (GHC.Types.N:IO[0] <GameTypes.Deck>_R)))
                        `cast`
                      (GHC.Types.N:IO[0] <GameTypes.Deck>_R)
                        eta of ds1 { (#,#) ipv ipv1 ->
                 (# ipv,
                    case Main.$wfirstHand
                           ipv1
                           (Main.createPlayers playerCount) of ww { (#,#) ww1 ww2 ->
                    GameTypes.Game
                      ww1
                      (GHC.Base.map
                         @ (GHC.Maybe.Maybe GameTypes.Player)
                         @ (GHC.Maybe.Maybe GameTypes.Player)
                         Main.continueRoundWithCurrentPlayer3
                         ww2) } #) }) -}
4d0ab67ab50d810232e27f1b810fa19e
  setupGame2 ::
    GameTypes.Deck
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GameTypes.Deck #)
  {- Arity: 2, Strictness: <S,1*U(U)><S,U>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GameTypes.Deck)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w of ww { GameTypes.Deck ww1 -> Main.$wshuffle ww1 w1 }) -}
d974be9c7d032ab0d1b7798873192642
  setupGame3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
90bd64e3549536a63a709c24686448ca
  showPlayerCards ::
    GameTypes.Game -> GameTypes.Id -> GHC.Base.String
  {- Arity: 2, Strictness: <S(LS),1*U(A,1*U)><L,U>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GameTypes.Game) (w1 :: GameTypes.Id) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 Main.$wshowPlayerCards ww2 w1 }) -}
1d28178d8fac83e368752641c2752717
  showPlayerCards1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.showPlayerCards2) -}
40af58b51ea5c30d9e24957e342282f9
  showPlayerCards2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", "#) -}
b5101007f2045bee355ac846300b81fc
  showPlayerCards_go :: [GameTypes.Card] -> [[GHC.Types.Char]]
  {- Arity: 1, Strictness: <S,1*U> -}
c708ab4832b8c55065b4a969542e7caf
  showPlayerScore ::
    GameTypes.Game -> GameTypes.Id -> GHC.Base.String
  {- Arity: 2, Strictness: <S(LS),1*U(A,1*U)><L,U>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GameTypes.Game) (w1 :: GameTypes.Id) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 Main.$wshowPlayerScore ww2 w1 }) -}
be265d9a21f2674ed68e3c5086fff46d
  shuffle :: GameTypes.Deck -> GHC.Types.IO GameTypes.Deck
  {- Arity: 2, Strictness: <S,1*U(U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.setupGame2
                  `cast`
                (<GameTypes.Deck>_R
                 ->_R Sym (GHC.Types.N:IO[0] <GameTypes.Deck>_R)) -}
b3133cd6d996564769f768cd4ea9f391
  shuffleDeck :: GameTypes.Deck -> GHC.Types.IO GameTypes.Deck
  {- Arity: 1, Strictness: <L,U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: GameTypes.Deck) ->
                 Main.shuffleDeck'
                   Main.shuffleDeck1
                   (Main.setupGame2 x)
                     `cast`
                   (Sym (GHC.Types.N:IO[0] <GameTypes.Deck>_R))) -}
3dc1d8c7f89e3a14d80c0b48a0fd064e
  shuffleDeck' ::
    GHC.Types.Int
    -> GHC.Types.IO GameTypes.Deck -> GHC.Types.IO GameTypes.Deck
  {- Arity: 2, Strictness: <S(S),1*U(1*U)><L,U>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: GHC.Types.IO GameTypes.Deck) ->
                 case w of ww { GHC.Types.I# ww1 -> Main.$wshuffleDeck' ww1 w1 }) -}
9a3bb766e0ed07d5aa8a1653d8cba6f0
  shuffleDeck1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 10000#) -}
a8203a083b7d220f0b0e10c0c677b82a
  startGame :: GHC.Types.IO GameTypes.Game
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.endGame3
                  `cast`
                (Sym (GHC.Types.N:IO[0] <GameTypes.Game>_R)) -}
7a03d3b76cc3421e5fe4a4873845ec9a
  suits :: [GameTypes.Suit]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Suit
                   GameTypes.Spade
                   Main.suits1) -}
cfeb155096761f6605c5fd05c0f0ee7b
  suits1 :: [GameTypes.Suit]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Suit
                   GameTypes.Club
                   Main.suits2) -}
6f9bd5e249ee3f53f58bffcfafbefe96
  suits2 :: [GameTypes.Suit]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Suit
                   GameTypes.Heart
                   Main.suits3) -}
39eb85d49b2bb814268ef0ef1fb26df8
  suits3 :: [GameTypes.Suit]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Suit
                   GameTypes.Diamond
                   (GHC.Types.[] @ GameTypes.Suit)) -}
trusted: safe
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

