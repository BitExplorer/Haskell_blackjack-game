
==================== FINAL INTERFACE ====================
2019-05-05 02:57:08.3483764 UTC

interface main:GameLogic 8064
  interface hash: 36b9277bff19e9bea2511436aa107189
  ABI hash: 6a2b257487ac107a03b410604db7acc5
  export-list hash: 7a513fc0946caf822384ba5b39650778
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: c81183b4f3dbe34d2e7de0e678a2e9cc
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  GameLogic.checkGameStatus
  GameLogic.checkPlayerScore
  GameLogic.dealCard
  GameLogic.determineWinner
  GameLogic.dropPlayer
  GameLogic.scoreAllPlayers
  GameLogic.setupGame
  GameLogic.showPlayerCards
  GameLogic.showPlayerScore
module dependencies: GameTypes
package dependencies: Win32-2.6.1.0 array-0.5.3.0 base-4.12.0.0*
                      deepseq-1.4.4.0 ghc-prim-0.5.3 integer-gmp-1.0.2.0 random-1.1*
                      time-1.8.0.2
orphans: time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.12.0.0:GHC.Float
         base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
import  -/  base-4.12.0.0:Data.Foldable 6673f41a7644ecd4dda455d741d47ef8
import  -/  base-4.12.0.0:Data.List ccb3c44b4e7df281b8508bfc1f389d8d
import  -/  base-4.12.0.0:Data.OldList cd51cf46346202f55e4ecde7f0f7b58e
import  -/  base-4.12.0.0:Data.Tuple ddbd97abaf9b62e84e82a5bae338d270
import  -/  base-4.12.0.0:GHC.Base 954f4c258d193fab7048a63bfeb56dcf
import  -/  base-4.12.0.0:GHC.List 63f1dc438c14c2ecfce50219fbb7ff35
import  -/  base-4.12.0.0:GHC.Num 009f4fca9200daff9e3ffbe2d7676a2f
import  -/  base-4.12.0.0:GHC.Real 2becc15d35863665b039224a7445f8b0
import  -/  base-4.12.0.0:GHC.Show 48dce8b8129312101170e57c24f3ecbd
import  -/  base-4.12.0.0:Prelude aea9afd24db8aed3563d7d850ea453c0
import  -/  ghc-prim-0.5.3:GHC.Classes 6002495dc43e58d28c87e5e5e058752a
import  -/  ghc-prim-0.5.3:GHC.Types 57064c9f957b09bc2e360061ad5cae0b
import  -/  integer-gmp-1.0.2.0:GHC.Integer.Type 34234e515bc4cbda6d7cda923884fd3f
import  -/  GameTypes 3f6d9af0e75c13797764bd61b26d7233
  exports: d0cfcd50ba0ec194499f629b661e84f4
  Ace 52657e73d7d3a148b4d7874f69732d00
  Card 53aa120e8bda0e36d71124dff7e413f2
  Card a8e6ae55fd67c3708fd7e810811aa74c
  Club 48c7e885560245b470508896bf619bb2
  Deck 5fcf2c22612a7cad4f7d6e887392c0b3
  Deck 96fdc6884b8f6c17d30f907111d27fd4
  Diamond 90e3a2532f3da5d97419ba8737e8ef86
  Eight 31b17d890cae70baefe6c72c06460387
  Five 28e767a48672ffde8dd2e4266053a97b
  Four fd193ea3f5353d6fbc14f1b3c7a5f76d
  Game a06bafd2ffb458968cf7f1709c1bbf99
  Game 3bce3074357214c65a171812000654b7
  Hand fb158e1dd79474cb6bc6571b5ed82bac
  Heart 1fc6e533fb2279799ec4d09ed93ded4f
  Id a797aeaff508cea35068e953c1207cac
  Jack b0516b00cd5b3cc9a86480afb5913c90
  King 972fe00e8411f8a39d0bdff1c62b471c
  Nine 15938efffa7bc00201530f59a32e40b2
  Player 99ad26c60237c8cdcd314f906a7664f7
  Player 1ebe2b600e107f45149573fcae7cfe3f
  Queen 0cd3f8923def08e588a3ef3ffda1f166
  Rank 9d82380a3c4835adca6131728c7ceaf9
  Score aee40ddf141d35912419bc402b0cc0b9
  Seven 02ad61fd46045fd4df0976aec6e64a33
  Six 230294c4865bd499c6025f7b33225504
  Spade dff612f9017ee9becc8054d6beb53f11
  Suit 5c027ad0dfa3cc5f2e1f8cd5b82c6b02
  Ten 6956e95545e63199d81954710e74f5ad
  Three bfb9b28cffb8f7871eba6e705e143999
  Two dcab1bab61f752409b7e46ec101a3abc
import  -/  random-1.1:System.Random 2df3d2176d852a42a0e8aa97126009b4
ecc8d98f5c4e9be8fdc8af1bc1d7797e
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   GameLogic.$trModule3
                   GameLogic.$trModule1) -}
1835d0b46795bedf67220eab0600ad12
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS GameLogic.$trModule2) -}
a5480c70aa279041c411ac6ab442334c
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("GameLogic"#) -}
3721804cf17598e15d27e271291691d8
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS GameLogic.$trModule4) -}
1127b6b0b8e69e4d4b23b8a5d09f933d
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
7963f6526087301b685c36d7ca00d989
  $wcheckGameStatus ::
    [GHC.Maybe.Maybe GameTypes.Player]
    -> GameTypes.Id -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>, Inline: [2],
     Unfolding: (\ (ww :: [GHC.Maybe.Maybe GameTypes.Player])
                   (w :: GameTypes.Id) ->
                 case GHC.List.$wlenAcc
                        @ (GHC.Maybe.Maybe GameTypes.Player)
                        ww
                        0# of ww2 { DEFAULT ->
                 case GHC.Integer.Type.ltInteger#
                        w
                        (GHC.Integer.Type.smallInteger ww2) of wild { DEFAULT ->
                 GHC.Prim.tagToEnum# @ GHC.Types.Bool wild } }) -}
7aa645ed6c604889253e6e80dd7277d7
  $wcheckPlayerScore ::
    [GHC.Maybe.Maybe GameTypes.Player]
    -> GameTypes.Id -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [2],
     Unfolding: (\ (ww :: [GHC.Maybe.Maybe GameTypes.Player])
                   (w :: GameTypes.Id) ->
                 letrec {
                   go2 :: [GHC.Maybe.Maybe GameTypes.Player] -> GHC.Types.Bool
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [GHC.Maybe.Maybe GameTypes.Player]) ->
                     case ds of wild {
                       [] -> GHC.Types.False
                       : y ys
                       -> case y of wild1 {
                            GHC.Maybe.Nothing -> go2 ys
                            GHC.Maybe.Just ds1
                            -> case ds1 of wild2 { GameTypes.Player i ds2 s ->
                               case GHC.Integer.Type.eqInteger# i w of wild3 {
                                 DEFAULT -> go2 ys
                                 1#
                                 -> case GHC.Integer.Type.gtInteger#
                                           s
                                           GameLogic.checkPlayerScore1 of wild4 { DEFAULT ->
                                    GHC.Prim.tagToEnum# @ GHC.Types.Bool wild4 } } } } }
                 } in
                 go2 ww) -}
71dfaf889f795c8d35f4db98b959f0e2
  $wdealCard ::
    [GameTypes.Card]
    -> [GHC.Maybe.Maybe GameTypes.Player]
    -> GameTypes.Id
    -> (# GameTypes.Deck, [GHC.Maybe.Maybe GameTypes.Player] #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,1*U><L,U>,
     Inline: [2],
     Unfolding: (\ (ww :: [GameTypes.Card])
                   (ww1 :: [GHC.Maybe.Maybe GameTypes.Player])
                   (w :: GameTypes.Id) ->
                 (# GameTypes.Deck (GameLogic.$wunsafeDrop @ GameTypes.Card 1# ww),
                    GHC.Base.map
                      @ (GHC.Maybe.Maybe GameTypes.Player)
                      @ (GHC.Maybe.Maybe GameTypes.Player)
                      (\ (m :: GHC.Maybe.Maybe GameTypes.Player) ->
                       case m of wild {
                         GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ GameTypes.Player
                         GHC.Maybe.Just p
                         -> case p of wild1 { GameTypes.Player x ds s ->
                            case ds of wild2 { GameTypes.Hand h ->
                            case GHC.Integer.Type.eqInteger# x w of wild3 {
                              DEFAULT -> wild
                              1#
                              -> GHC.Maybe.Just
                                   @ GameTypes.Player
                                   (GameTypes.Player
                                      x
                                      (GameTypes.Hand
                                         (letrec {
                                            $wgo2 :: [GameTypes.Card]
                                                     -> GHC.Prim.Int# -> [GameTypes.Card]
                                              {- Arity: 2, Strictness: <S,1*U><L,1*U>,
                                                 Inline: [2] -}
                                            = \ (w1 :: [GameTypes.Card]) (ww2 :: GHC.Prim.Int#) ->
                                              case w1 of wild4 {
                                                [] -> h
                                                : y ys
                                                -> case ww2 of ds1 {
                                                     DEFAULT
                                                     -> GHC.Types.:
                                                          @ GameTypes.Card
                                                          y
                                                          ($wgo2 ys (GHC.Prim.-# ds1 1#))
                                                     1# -> GHC.Types.: @ GameTypes.Card y h } }
                                          } in
                                          $wgo2 ww 1#))
                                      s) } } } })
                      ww1 #)) -}
7c2873d1e4829385dac80628aee4abca
  $wdetermineWinner ::
    [GHC.Maybe.Maybe GameTypes.Player]
    -> GHC.Maybe.Maybe (GameTypes.Id, GameTypes.Score)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2],
     Unfolding: (\ (ww :: [GHC.Maybe.Maybe GameTypes.Player]) ->
                 case ww of wild {
                   [] -> GameLogic.determineWinner1
                   : player players -> GameLogic.determineWinner_go players }) -}
fb3cd8978d1bbd61b437c456e5ddcb0b
  $wgo ::
    GameTypes.Deck
    -> [GHC.Maybe.Maybe GameTypes.Player]
    -> GHC.Integer.Type.Integer
    -> (# GameTypes.Deck, [GHC.Maybe.Maybe GameTypes.Player] #)
  {- Arity: 3, Strictness: <L,U(U)><L,U><S,U>, Inline: [2] -}
3219c8fedd2d5403e75a17d159911b19
  $wgo1 ::
    [GameTypes.Card]
    -> [GameTypes.Card] -> (# [GameTypes.Card], [GameTypes.Card] #)
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [2] -}
9182583c2c939bcf4cc41d6ba9c99779
  $wshowPlayerCards ::
    [GHC.Maybe.Maybe GameTypes.Player]
    -> GameTypes.Id -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [2],
     Unfolding: (\ (ww :: [GHC.Maybe.Maybe GameTypes.Player])
                   (w :: GameTypes.Id) ->
                 letrec {
                   go2 :: [GHC.Maybe.Maybe GameTypes.Player] -> [GHC.Types.Char]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [GHC.Maybe.Maybe GameTypes.Player]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ GHC.Types.Char
                       : y ys
                       -> case y of wild1 {
                            GHC.Maybe.Nothing -> go2 ys
                            GHC.Maybe.Just ds1
                            -> case ds1 of wild2 { GameTypes.Player i ds2 ds3 ->
                               case ds2 of wild3 { GameTypes.Hand cs ->
                               case GHC.Integer.Type.eqInteger# i w of wild4 {
                                 DEFAULT -> go2 ys
                                 1#
                                 -> case GameLogic.showPlayerCards_go cs of wild5 {
                                      [] -> go2 ys
                                      : x xs1
                                      -> GHC.Base.++
                                           @ GHC.Types.Char
                                           (Data.OldList.intercalate1
                                              @ GHC.Types.Char
                                              (GHC.Types.:
                                                 @ [GHC.Types.Char]
                                                 x
                                                 (Data.OldList.prependToAll
                                                    @ [GHC.Types.Char]
                                                    GameLogic.showPlayerCards1
                                                    xs1)))
                                           (go2 ys) } } } } } }
                 } in
                 go2 ww) -}
474cf837fcc7eb8f0f631fdb84675441
  $wshowPlayerScore ::
    [GHC.Maybe.Maybe GameTypes.Player]
    -> GameTypes.Id -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [2],
     Unfolding: (\ (ww :: [GHC.Maybe.Maybe GameTypes.Player])
                   (w :: GameTypes.Id) ->
                 letrec {
                   go2 :: [GHC.Maybe.Maybe GameTypes.Player] -> [GHC.Types.Char]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [GHC.Maybe.Maybe GameTypes.Player]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ GHC.Types.Char
                       : y ys
                       -> case y of wild1 {
                            GHC.Maybe.Nothing -> go2 ys
                            GHC.Maybe.Just ds1
                            -> case ds1 of wild2 { GameTypes.Player i ds2 s ->
                               case GHC.Integer.Type.eqInteger# i w of wild3 {
                                 DEFAULT -> go2 ys
                                 1#
                                 -> case GHC.Show.$w$cshowsPrec4
                                           0#
                                           s
                                           (GHC.Types.[] @ GHC.Types.Char) of ww2 { (#,#) ww3 ww4 ->
                                    GHC.Base.++
                                      @ GHC.Types.Char
                                      (GHC.Types.: @ GHC.Types.Char ww3 ww4)
                                      (go2 ys) } } } } }
                 } in
                 go2 ww) -}
bd04b8dddd46f48f27440fbe11d789bb
  $wshuffle ::
    [GameTypes.Card]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GameTypes.Deck #)
  {- Arity: 2, Strictness: <L,U><S,U>, Inline: [2],
     Unfolding: (\ (ww :: [GameTypes.Card])
                   (w :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.Random.$fRandomInt3
                        (GameLogic.setupGame17,
                         case GHC.List.$wlenAcc @ GameTypes.Card ww 0# of ww2 { DEFAULT ->
                         GHC.Types.I# (GHC.Prim.-# ww2 1#) })
                        w of ds1 { (#,#) ipv ipv1 ->
                 (# ipv,
                    case ipv1 of wild { GHC.Types.I# x ->
                    case GHC.Prim.<=# x 0# of lwild {
                      DEFAULT
                      -> case GHC.List.$wsplitAt'
                                @ GameTypes.Card
                                wild
                                ww of ww1 { (#,#) ww2 ww3 ->
                         GameLogic.setupGame16 ww2 ww3 }
                      1#
                      -> GameLogic.setupGame16
                           (GHC.Types.[] @ GameTypes.Card)
                           ww } } #) }) -}
c83876aab5241919c70c7b1062553318
  $wshuffleDeck' ::
    GHC.Prim.Int#
    -> GHC.Types.IO GameTypes.Deck
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GameTypes.Deck #)
  {- Arity: 3, Strictness: <S,1*U><C(S),1*C1(U(U,U(U)))><S,U>,
     Inline: [2] -}
3e56390827e44554b42f97128fa43626
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [2] -}
f3d59d0dd4503089a0aae1bb93dccca3
  checkGameStatus :: GameTypes.Game -> GameTypes.Id -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)><S,U>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GameTypes.Game) (w1 :: GameTypes.Id) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 GameLogic.$wcheckGameStatus ww2 w1 }) -}
05dabf585ac7e30ff631a162718d5e90
  checkPlayerScore ::
    GameTypes.Game -> GameTypes.Id -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)><L,U>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GameTypes.Game) (w1 :: GameTypes.Id) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 GameLogic.$wcheckPlayerScore ww2 w1 }) -}
868ef658ae5040f41e81c86b16ca592f
  checkPlayerScore1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (21) -}
2236224d5cfae2ffb4b516c168c479b2
  createPlayers ::
    GHC.Integer.Type.Integer -> [GHC.Maybe.Maybe GameTypes.Player]
  {- Arity: 1, Strictness: <S,U> -}
bb2870dba2d23ecb892b41e92376e72c
  dealCard :: GameTypes.Game -> GameTypes.Id -> GameTypes.Game
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U(U),1*U)><L,U>m, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GameTypes.Game) (w1 :: GameTypes.Id) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 case ww1 of ww3 { GameTypes.Deck ww4 ->
                 case GameLogic.$wdealCard ww4 ww2 w1 of ww5 { (#,#) ww6 ww7 ->
                 GameTypes.Game ww6 ww7 } } }) -}
7b529e7a777f273ff4dc93f04cfc6bb8
  determineWinner ::
    GameTypes.Game -> GHC.Maybe.Maybe (GameTypes.Id, GameTypes.Score)
  {- Arity: 1, Strictness: <S(LS),1*U(A,1*U)>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GameTypes.Game) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 GameLogic.$wdetermineWinner ww2 }) -}
d228d2e624395a7aec49b69dfa676561
  determineWinner1 :: GHC.Maybe.Maybe (GameTypes.Id, GameTypes.Score)
  {- Strictness: x -}
9a84c91262d0475b7dbf24cdbeac51a4
  determineWinner_go ::
    [GHC.Maybe.Maybe GameTypes.Player]
    -> GHC.Maybe.Maybe (GameTypes.Id, GameTypes.Score)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
ba6328f19876656956b288d6b3f66030
  dropPlayer :: GameTypes.Game -> GameTypes.Id -> GameTypes.Game
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U,1*U)><L,U>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GameTypes.Game) (w1 :: GameTypes.Id) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 GameTypes.Game
                   ww1
                   (GHC.Base.build
                      @ (GHC.Maybe.Maybe GameTypes.Player)
                      (\ @ b1
                         (c :: GHC.Maybe.Maybe GameTypes.Player -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ (GHC.Maybe.Maybe GameTypes.Player)
                         @ b1
                         (GHC.Base.mapFB
                            @ (GHC.Maybe.Maybe GameTypes.Player)
                            @ b1
                            @ (GHC.Maybe.Maybe GameTypes.Player)
                            c
                            (\ (m :: GHC.Maybe.Maybe GameTypes.Player) ->
                             case m of wild {
                               GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ GameTypes.Player
                               GHC.Maybe.Just p
                               -> case p of wild1 { GameTypes.Player i ds ds1 ->
                                  case GHC.Integer.Type.eqInteger# i w1 of wild2 {
                                    DEFAULT -> GHC.Maybe.Just @ GameTypes.Player wild1
                                    1# -> GHC.Maybe.Nothing @ GameTypes.Player } } }))
                         n
                         ww2)) }) -}
89ac6fd95a378e530753950815a9c7da
  scoreAllPlayers :: GameTypes.Game -> GameTypes.Game
  {- Arity: 1, Strictness: <S,1*U(U,1*U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GameTypes.Game) ->
                 case ds of wild { GameTypes.Game deck players ->
                 GameTypes.Game
                   deck
                   (GHC.Base.build
                      @ (GHC.Maybe.Maybe GameTypes.Player)
                      (\ @ b1
                         (c :: GHC.Maybe.Maybe GameTypes.Player -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ (GHC.Maybe.Maybe GameTypes.Player)
                         @ b1
                         (GHC.Base.mapFB
                            @ (GHC.Maybe.Maybe GameTypes.Player)
                            @ b1
                            @ (GHC.Maybe.Maybe GameTypes.Player)
                            c
                            GameLogic.scoreAllPlayers1)
                         n
                         players)) }) -}
d97b0d6aeff0d437667b256715bbdc89
  scoreAllPlayers1 ::
    GHC.Maybe.Maybe GameTypes.Player
    -> GHC.Maybe.Maybe GameTypes.Player
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds1 :: GHC.Maybe.Maybe GameTypes.Player) ->
                 case ds1 of wild {
                   GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ GameTypes.Player
                   GHC.Maybe.Just a1
                   -> GHC.Maybe.Just
                        @ GameTypes.Player
                        (case a1 of wild1 { GameTypes.Player id h ds ->
                         case h of wild2 { GameTypes.Hand cards ->
                         GameTypes.Player
                           id
                           wild2
                           (let {
                              temp :: GHC.Integer.Type.Integer
                              = GameLogic.scoreAllPlayers_go1 cards
                            } in
                            case GHC.Integer.Type.gtInteger#
                                   temp
                                   GameLogic.checkPlayerScore1 of wild3 {
                              DEFAULT -> temp
                              1# -> GameLogic.scoreAllPlayers_go cards }) } }) }) -}
49d6a1eaa5afd467ac99f95aeee29fa2
  scoreAllPlayers_go :: [GameTypes.Card] -> GHC.Integer.Type.Integer
  {- Arity: 1, Strictness: <S,1*U> -}
0ad1db3b0640a17d015db6bb4c4a5ae8
  scoreAllPlayers_go1 :: [GameTypes.Card] -> GHC.Integer.Type.Integer
  {- Arity: 1, Strictness: <S,1*U> -}
645bc94e4a876edcff6562482c808b17
  setupGame ::
    GHC.Integer.Type.Integer -> GHC.Types.IO GameTypes.Game
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                GameLogic.setupGame1
                  `cast`
                (<GHC.Integer.Type.Integer>_R
                 ->_R Sym (GHC.Types.N:IO[0] <GameTypes.Game>_R)) -}
60df05a7d82dbc7dabf844e2c6ccdce1
  setupGame1 ::
    GHC.Integer.Type.Integer
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GameTypes.Game #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (playerCount :: GHC.Integer.Type.Integer)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GameLogic.$wshuffleDeck'
                        10000#
                        GameLogic.setupGame2
                          `cast`
                        (Sym (GHC.Types.N:IO[0] <GameTypes.Deck>_R))
                        eta of ds1 { (#,#) ipv ipv1 ->
                 (# ipv,
                    let {
                      players :: [GHC.Maybe.Maybe GameTypes.Player]
                      = GameLogic.createPlayers playerCount
                    } in
                    case GHC.List.$wlenAcc
                           @ (GHC.Maybe.Maybe GameTypes.Player)
                           players
                           0# of ww2 { DEFAULT ->
                    let {
                      c :: GHC.Integer.Type.Integer = GHC.Integer.Type.smallInteger ww2
                    } in
                    case GameLogic.$wgo ipv1 players c of ww { (#,#) ww1 ww3 ->
                    case GameLogic.$wgo ww1 ww3 c of ww4 { (#,#) ww5 ww6 ->
                    GameTypes.Game
                      ww5
                      (GHC.Base.map
                         @ (GHC.Maybe.Maybe GameTypes.Player)
                         @ (GHC.Maybe.Maybe GameTypes.Player)
                         GameLogic.scoreAllPlayers1
                         ww6) } } } #) }) -}
cfbe7d9d2e819d8f4a39dd02fae6d823
  setupGame10 :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.Eight
                   GameLogic.setupGame11) -}
bed43efb7badf80e5c838654e151ff78
  setupGame11 :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.Nine
                   GameLogic.setupGame12) -}
970cd9c1c04b6e970d3fa2add349c75b
  setupGame12 :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.Ten
                   GameLogic.setupGame13) -}
d7d569b264d7b4e0f1f605893e15a00a
  setupGame13 :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.Jack
                   GameLogic.setupGame14) -}
0726f7adc9befff44a8be70b106936a1
  setupGame14 :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.Queen
                   GameLogic.setupGame15) -}
c8a55ef70f8e619f2c4e772d04cb0389
  setupGame15 :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.King
                   (GHC.Types.[] @ GameTypes.Rank)) -}
78b38a458a756d484c03c41095b88634
  setupGame16 ::
    [GameTypes.Card] -> [GameTypes.Card] -> GameTypes.Deck
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m,
     Unfolding: (\ (ww :: [GameTypes.Card])[OneShot]
                   (ww1 :: [GameTypes.Card])[OneShot] ->
                 case GameLogic.$wgo1 ww ww1 of ww2 { (#,#) ww3 ww4 ->
                 GameTypes.Deck
                   (GameLogic.setupGame_go1
                      (Data.OldList.transpose
                         @ GameTypes.Card
                         (GHC.Types.:
                            @ [GameTypes.Card]
                            ww3
                            (GHC.Types.:
                               @ [GameTypes.Card]
                               ww4
                               (GHC.Types.[] @ [GameTypes.Card]))))) }) -}
344cd40cadb04103a268f7978620cc56
  setupGame17 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
b06a4f5f4114fdd1bb26355ced753abf
  setupGame2 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GameTypes.Deck #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (w :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 GameLogic.$wshuffle GameLogic.setupGame3 w) -}
416a9c940647ca410330e9d4a09f1676
  setupGame3 :: [GameTypes.Card]
  {- Unfolding: (GameLogic.setupGame_go GameLogic.setupGame_ranks) -}
4b2a1dd6a82be94d23b05d3c9e95fb48
  setupGame4 :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.Two
                   GameLogic.setupGame5) -}
92a4f80fa628be4a0c9328b71b0b92d8
  setupGame5 :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.Three
                   GameLogic.setupGame6) -}
7264d0addc525787bd11373913d4a82c
  setupGame6 :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.Four
                   GameLogic.setupGame7) -}
3155380e929b56002096ae9c7dcd48d0
  setupGame7 :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.Five
                   GameLogic.setupGame8) -}
55f7f77ec22abed8c9f10e1758ec149b
  setupGame8 :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.Six
                   GameLogic.setupGame9) -}
b4f0dd4ac3b5b24886e0e62e81bf03a2
  setupGame9 :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.Seven
                   GameLogic.setupGame10) -}
54355ac38fb8b48ac3938ad18a5fbd9b
  setupGame_go :: [GameTypes.Rank] -> [GameTypes.Card]
  {- Arity: 1, Strictness: <S,1*U> -}
a0a60fbeeb90e579205e95687342478c
  setupGame_go1 :: [[GameTypes.Card]] -> [GameTypes.Card]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
d6f0e0c4f55cbee41917b3c3cb3106b5
  setupGame_ranks :: [GameTypes.Rank]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GameTypes.Rank
                   GameTypes.Ace
                   GameLogic.setupGame4) -}
7520c906f1272e717b90f8a1fc2b520e
  showPlayerCards ::
    GameTypes.Game -> GameTypes.Id -> GHC.Base.String
  {- Arity: 2, Strictness: <S(LS),1*U(A,1*U)><L,U>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GameTypes.Game) (w1 :: GameTypes.Id) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 GameLogic.$wshowPlayerCards ww2 w1 }) -}
ad96e6d9fca2267423cd44e3df39a151
  showPlayerCards1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   GameLogic.showPlayerCards2) -}
a761f57c21ccfca7ba6add97f9b5b95a
  showPlayerCards2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", "#) -}
9850452bac05ef8b509dfb51a7963a92
  showPlayerCards_go :: [GameTypes.Card] -> [[GHC.Types.Char]]
  {- Arity: 1, Strictness: <S,1*U> -}
2916c94234a3569675e7952c93f754ac
  showPlayerScore ::
    GameTypes.Game -> GameTypes.Id -> GHC.Base.String
  {- Arity: 2, Strictness: <S(LS),1*U(A,1*U)><L,U>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GameTypes.Game) (w1 :: GameTypes.Id) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 GameLogic.$wshowPlayerScore ww2 w1 }) -}
trusted: safe
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

