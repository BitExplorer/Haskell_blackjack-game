
==================== FINAL INTERFACE ====================
2019-05-05 03:16:43.906074 UTC

interface main:GameLogic 8064
  interface hash: 921c9903082808cdeed7334ea3e00892
  ABI hash: 0bf42e1352edb1572b53530454a6d832
  export-list hash: 7a513fc0946caf822384ba5b39650778
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: c81183b4f3dbe34d2e7de0e678a2e9cc
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  GameLogic.checkGameStatus
  GameLogic.checkPlayerScore
  GameLogic.dealCard
  GameLogic.determineWinner
  GameLogic.dropPlayer
  GameLogic.scoreAllPlayers
  GameLogic.setupGame
  GameLogic.showPlayerCards
  GameLogic.showPlayerScore
module dependencies: GameTypes
package dependencies: Win32-2.6.1.0 array-0.5.3.0 base-4.12.0.0*
                      deepseq-1.4.4.0 ghc-prim-0.5.3 integer-gmp-1.0.2.0 random-1.1*
                      time-1.8.0.2
orphans: time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.12.0.0:GHC.Float
         base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
import  -/  base-4.12.0.0:Data.Foldable 6673f41a7644ecd4dda455d741d47ef8
import  -/  base-4.12.0.0:Data.List ccb3c44b4e7df281b8508bfc1f389d8d
import  -/  base-4.12.0.0:Data.OldList cd51cf46346202f55e4ecde7f0f7b58e
import  -/  base-4.12.0.0:Data.Tuple ddbd97abaf9b62e84e82a5bae338d270
import  -/  base-4.12.0.0:GHC.Base 954f4c258d193fab7048a63bfeb56dcf
import  -/  base-4.12.0.0:GHC.List 63f1dc438c14c2ecfce50219fbb7ff35
import  -/  base-4.12.0.0:GHC.Num 009f4fca9200daff9e3ffbe2d7676a2f
import  -/  base-4.12.0.0:GHC.Real 2becc15d35863665b039224a7445f8b0
import  -/  base-4.12.0.0:GHC.Show 48dce8b8129312101170e57c24f3ecbd
import  -/  base-4.12.0.0:Prelude aea9afd24db8aed3563d7d850ea453c0
import  -/  ghc-prim-0.5.3:GHC.Classes 6002495dc43e58d28c87e5e5e058752a
import  -/  ghc-prim-0.5.3:GHC.Types 57064c9f957b09bc2e360061ad5cae0b
import  -/  integer-gmp-1.0.2.0:GHC.Integer.Type 34234e515bc4cbda6d7cda923884fd3f
import  -/  GameTypes b7d560a7947944d08410c28da6bb84e6
  exports: d0cfcd50ba0ec194499f629b661e84f4
  Ace 68b724b1facc502b615f393bcd831115
  Card 6f4a846a34b1fef2f64be6d1a0814a97
  Card 6215c90c2c8c4624c983fc6bd02d9fdd
  Deck a2ae1cdbb4aced0d0beee67f8b75c222
  Deck 6ba9f765828f94acae51ec362b4412cf
  Diamond 683eec62ad4f13e51ae02b3bdfa6fb30
  Eight 388a25c8042ec334d647b89a8cc4775c
  Five 36ea0a5f250933e46c4f467ff3614b69
  Four 986f788bc26825d445ef204dd2d14d20
  Game df4a6ea862cb79b654f4de64ca440e65
  Game bff7543e1bf5fadbb445e5528834512e
  Hand be1ba74fd50ca1bb32599f84f835b14c
  Id a797aeaff508cea35068e953c1207cac
  King 2437e4ed02089ac4d8bea8941c6b4870
  Nine 53511abd9e3ea6af06348517616f9050
  Player cc1aaafab82d20fa5adf87b8fee319dc
  Player 2002e0599069a975c1ee8d2a8afe91cf
  Rank f040b2257d2b1a88badd3110d99fdf9f
  Score aee40ddf141d35912419bc402b0cc0b9
  Seven 6f5d0fba03cc03aa33a75cac18379f42
  Six 4742141266fc6eec1d42390f2bb39317
  Spade 3d351f2333872f8d03c44b0dab114ebe
  Suit ecd83c74f178132c266c910d7a0d4b3b
  Three bf64af8e32c133dda5791243967779ae
  Two cf0a72b9ae8c69c988e6f71c89686f71
import  -/  random-1.1:System.Random 2df3d2176d852a42a0e8aa97126009b4
ecc8d98f5c4e9be8fdc8af1bc1d7797e
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   GameLogic.$trModule3
                   GameLogic.$trModule1) -}
1835d0b46795bedf67220eab0600ad12
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS GameLogic.$trModule2) -}
a5480c70aa279041c411ac6ab442334c
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("GameLogic"#) -}
3721804cf17598e15d27e271291691d8
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS GameLogic.$trModule4) -}
1127b6b0b8e69e4d4b23b8a5d09f933d
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
fb1fd58745a69768541060fd5f326543
  $wcheckGameStatus ::
    [GHC.Maybe.Maybe GameTypes.Player]
    -> GameTypes.Id -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>, Inline: [2],
     Unfolding: (\ (ww :: [GHC.Maybe.Maybe GameTypes.Player])
                   (w :: GameTypes.Id) ->
                 case GHC.List.$wlenAcc
                        @ (GHC.Maybe.Maybe GameTypes.Player)
                        ww
                        0# of ww2 { DEFAULT ->
                 case GHC.Integer.Type.ltInteger#
                        w
                        (GHC.Integer.Type.smallInteger ww2) of wild { DEFAULT ->
                 GHC.Prim.tagToEnum# @ GHC.Types.Bool wild } }) -}
719723b94d88be0d2715354dcda9a627
  $wcheckPlayerScore ::
    [GHC.Maybe.Maybe GameTypes.Player]
    -> GameTypes.Id -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [2],
     Unfolding: (\ (ww :: [GHC.Maybe.Maybe GameTypes.Player])
                   (w :: GameTypes.Id) ->
                 letrec {
                   go :: [GHC.Maybe.Maybe GameTypes.Player] -> GHC.Types.Bool
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [GHC.Maybe.Maybe GameTypes.Player]) ->
                     case ds of wild {
                       [] -> GHC.Types.False
                       : y ys
                       -> case y of wild1 {
                            GHC.Maybe.Nothing -> go ys
                            GHC.Maybe.Just ds1
                            -> case ds1 of wild2 { GameTypes.Player i ds2 s ->
                               case GHC.Integer.Type.eqInteger# i w of wild3 {
                                 DEFAULT -> go ys
                                 1#
                                 -> case GHC.Integer.Type.gtInteger#
                                           s
                                           GameLogic.checkPlayerScore1 of wild4 { DEFAULT ->
                                    GHC.Prim.tagToEnum# @ GHC.Types.Bool wild4 } } } } }
                 } in
                 go ww) -}
e4ad07b0d4472a637fad1b3786859736
  $wdealCard ::
    [GameTypes.Card]
    -> [GHC.Maybe.Maybe GameTypes.Player]
    -> GameTypes.Id
    -> (# GameTypes.Deck, [GHC.Maybe.Maybe GameTypes.Player] #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,1*U><L,U>,
     Inline: [2],
     Unfolding: (\ (ww :: [GameTypes.Card])
                   (ww1 :: [GHC.Maybe.Maybe GameTypes.Player])
                   (w :: GameTypes.Id) ->
                 (# GameTypes.Deck (GameLogic.$wunsafeDrop @ GameTypes.Card 1# ww),
                    GHC.Base.map
                      @ (GHC.Maybe.Maybe GameTypes.Player)
                      @ (GHC.Maybe.Maybe GameTypes.Player)
                      (\ (m :: GHC.Maybe.Maybe GameTypes.Player) ->
                       case m of wild {
                         GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ GameTypes.Player
                         GHC.Maybe.Just p
                         -> case p of wild1 { GameTypes.Player x ds s ->
                            case ds of wild2 { GameTypes.Hand h ->
                            case GHC.Integer.Type.eqInteger# x w of wild3 {
                              DEFAULT -> wild
                              1#
                              -> GHC.Maybe.Just
                                   @ GameTypes.Player
                                   (GameTypes.Player
                                      x
                                      (GameTypes.Hand
                                         (letrec {
                                            $wgo2 :: [GameTypes.Card]
                                                     -> GHC.Prim.Int# -> [GameTypes.Card]
                                              {- Arity: 2, Strictness: <S,1*U><L,1*U>,
                                                 Inline: [2] -}
                                            = \ (w1 :: [GameTypes.Card]) (ww2 :: GHC.Prim.Int#) ->
                                              case w1 of wild4 {
                                                [] -> h
                                                : y ys
                                                -> case ww2 of ds1 {
                                                     DEFAULT
                                                     -> GHC.Types.:
                                                          @ GameTypes.Card
                                                          y
                                                          ($wgo2 ys (GHC.Prim.-# ds1 1#))
                                                     1# -> GHC.Types.: @ GameTypes.Card y h } }
                                          } in
                                          $wgo2 ww 1#))
                                      s) } } } })
                      ww1 #)) -}
3a6ba0fbf806bab7e2afdff29b20de74
  $wgo ::
    GameTypes.Deck
    -> [GHC.Maybe.Maybe GameTypes.Player]
    -> GHC.Integer.Type.Integer
    -> (# GameTypes.Deck, [GHC.Maybe.Maybe GameTypes.Player] #)
  {- Arity: 3, Strictness: <L,U(U)><L,U><S,U>, Inline: [2] -}
25ed4aec9d84264b339e4e3cedb7a1d6
  $wgo1 ::
    [GameTypes.Card]
    -> [GameTypes.Card] -> (# [GameTypes.Card], [GameTypes.Card] #)
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [2] -}
01c5402218f993454a0260e9108590be
  $wshowPlayerCards ::
    [GHC.Maybe.Maybe GameTypes.Player]
    -> GameTypes.Id -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [2],
     Unfolding: (\ (ww :: [GHC.Maybe.Maybe GameTypes.Player])
                   (w :: GameTypes.Id) ->
                 letrec {
                   go :: [GHC.Maybe.Maybe GameTypes.Player] -> [GHC.Types.Char]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [GHC.Maybe.Maybe GameTypes.Player]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ GHC.Types.Char
                       : y ys
                       -> case y of wild1 {
                            GHC.Maybe.Nothing -> go ys
                            GHC.Maybe.Just ds1
                            -> case ds1 of wild2 { GameTypes.Player i ds2 ds3 ->
                               case ds2 of wild3 { GameTypes.Hand cs ->
                               case GHC.Integer.Type.eqInteger# i w of wild4 {
                                 DEFAULT -> go ys
                                 1#
                                 -> case GameLogic.showPlayerCards_go cs of wild5 {
                                      [] -> go ys
                                      : x xs1
                                      -> GHC.Base.++
                                           @ GHC.Types.Char
                                           (Data.OldList.intercalate1
                                              @ GHC.Types.Char
                                              (GHC.Types.:
                                                 @ [GHC.Types.Char]
                                                 x
                                                 (Data.OldList.prependToAll
                                                    @ [GHC.Types.Char]
                                                    GameLogic.showPlayerCards1
                                                    xs1)))
                                           (go ys) } } } } } }
                 } in
                 go ww) -}
ae8fe46d14388153fea9e6ce21e92236
  $wshowPlayerScore ::
    [GHC.Maybe.Maybe GameTypes.Player]
    -> GameTypes.Id -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [2],
     Unfolding: (\ (ww :: [GHC.Maybe.Maybe GameTypes.Player])
                   (w :: GameTypes.Id) ->
                 letrec {
                   go :: [GHC.Maybe.Maybe GameTypes.Player] -> [GHC.Types.Char]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [GHC.Maybe.Maybe GameTypes.Player]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ GHC.Types.Char
                       : y ys
                       -> case y of wild1 {
                            GHC.Maybe.Nothing -> go ys
                            GHC.Maybe.Just ds1
                            -> case ds1 of wild2 { GameTypes.Player i ds2 s ->
                               case GHC.Integer.Type.eqInteger# i w of wild3 {
                                 DEFAULT -> go ys
                                 1#
                                 -> case GHC.Show.$w$cshowsPrec4
                                           0#
                                           s
                                           (GHC.Types.[] @ GHC.Types.Char) of ww2 { (#,#) ww3 ww4 ->
                                    GHC.Base.++
                                      @ GHC.Types.Char
                                      (GHC.Types.: @ GHC.Types.Char ww3 ww4)
                                      (go ys) } } } } }
                 } in
                 go ww) -}
eefdf6213bcddf5ed34a9ff2f0b4a0ed
  $wshuffle ::
    [GameTypes.Card]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GameTypes.Deck #)
  {- Arity: 2, Strictness: <L,U><S,U>, Inline: [2],
     Unfolding: (\ (ww :: [GameTypes.Card])
                   (w :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.Random.$fRandomInt3
                        (GameLogic.setupGame5,
                         case GHC.List.$wlenAcc @ GameTypes.Card ww 0# of ww2 { DEFAULT ->
                         GHC.Types.I# (GHC.Prim.-# ww2 1#) })
                        w of ds1 { (#,#) ipv ipv1 ->
                 (# ipv,
                    case ipv1 of wild { GHC.Types.I# x ->
                    case GHC.Prim.<=# x 0# of lwild {
                      DEFAULT
                      -> case GHC.List.$wsplitAt'
                                @ GameTypes.Card
                                wild
                                ww of ww1 { (#,#) ww2 ww3 ->
                         GameLogic.setupGame4 ww2 ww3 }
                      1#
                      -> GameLogic.setupGame4
                           (GHC.Types.[] @ GameTypes.Card)
                           ww } } #) }) -}
016deee90e3fe25d8652e958aceb73a5
  $wshuffleDeck' ::
    GHC.Prim.Int#
    -> GHC.Types.IO GameTypes.Deck
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GameTypes.Deck #)
  {- Arity: 3, Strictness: <S,1*U><C(S),1*C1(U(U,U(U)))><S,U>,
     Inline: [2] -}
3e56390827e44554b42f97128fa43626
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [2] -}
2cbd14b05b8ba1fb2f08e9807f346a4d
  checkGameStatus :: GameTypes.Game -> GameTypes.Id -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)><S,U>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GameTypes.Game) (w1 :: GameTypes.Id) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 GameLogic.$wcheckGameStatus ww2 w1 }) -}
7e55c89ceaf0f6a3e9c9cfdeca2b7bdb
  checkPlayerScore ::
    GameTypes.Game -> GameTypes.Id -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)><L,U>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GameTypes.Game) (w1 :: GameTypes.Id) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 GameLogic.$wcheckPlayerScore ww2 w1 }) -}
868ef658ae5040f41e81c86b16ca592f
  checkPlayerScore1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (21) -}
ae192a9de1d2420d94afd6574e10442c
  createPlayers ::
    GHC.Integer.Type.Integer -> [GHC.Maybe.Maybe GameTypes.Player]
  {- Arity: 1, Strictness: <S,U> -}
63884a3ef5bbd96ef6c659c23e6c9adb
  dealCard :: GameTypes.Game -> GameTypes.Id -> GameTypes.Game
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U(U),1*U)><L,U>m, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GameTypes.Game) (w1 :: GameTypes.Id) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 case ww1 of ww3 { GameTypes.Deck ww4 ->
                 case GameLogic.$wdealCard ww4 ww2 w1 of ww5 { (#,#) ww6 ww7 ->
                 GameTypes.Game ww6 ww7 } } }) -}
bbf987c087a010326f4727d9e0a69cc7
  determineWinner ::
    GameTypes.Game -> GHC.Maybe.Maybe (GameTypes.Id, GameTypes.Score)
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GameTypes.Game) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 GameLogic.determineWinner_go ww2 }) -}
f4fe399d8eb6092ab54d3378c67d44d0
  determineWinner_go ::
    [GHC.Maybe.Maybe GameTypes.Player]
    -> GHC.Maybe.Maybe (GameTypes.Id, GameTypes.Score)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
1d57a66a20c2f628123f6ad268f697bf
  dropPlayer :: GameTypes.Game -> GameTypes.Id -> GameTypes.Game
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U,1*U)><L,U>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GameTypes.Game) (w1 :: GameTypes.Id) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 GameTypes.Game
                   ww1
                   (GHC.Base.build
                      @ (GHC.Maybe.Maybe GameTypes.Player)
                      (\ @ b1
                         (c :: GHC.Maybe.Maybe GameTypes.Player -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ (GHC.Maybe.Maybe GameTypes.Player)
                         @ b1
                         (GHC.Base.mapFB
                            @ (GHC.Maybe.Maybe GameTypes.Player)
                            @ b1
                            @ (GHC.Maybe.Maybe GameTypes.Player)
                            c
                            (\ (m :: GHC.Maybe.Maybe GameTypes.Player) ->
                             case m of wild {
                               GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ GameTypes.Player
                               GHC.Maybe.Just p
                               -> case p of wild1 { GameTypes.Player i ds ds1 ->
                                  case GHC.Integer.Type.eqInteger# i w1 of wild2 {
                                    DEFAULT -> GHC.Maybe.Just @ GameTypes.Player wild1
                                    1# -> GHC.Maybe.Nothing @ GameTypes.Player } } }))
                         n
                         ww2)) }) -}
000aa34840030da3e6f7bcbd9f530b39
  scoreAllPlayers :: GameTypes.Game -> GameTypes.Game
  {- Arity: 1, Strictness: <S,1*U(U,1*U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GameTypes.Game) ->
                 case ds of wild { GameTypes.Game deck players ->
                 GameTypes.Game
                   deck
                   (GHC.Base.build
                      @ (GHC.Maybe.Maybe GameTypes.Player)
                      (\ @ b1
                         (c :: GHC.Maybe.Maybe GameTypes.Player -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ (GHC.Maybe.Maybe GameTypes.Player)
                         @ b1
                         (GHC.Base.mapFB
                            @ (GHC.Maybe.Maybe GameTypes.Player)
                            @ b1
                            @ (GHC.Maybe.Maybe GameTypes.Player)
                            c
                            GameLogic.scoreAllPlayers1)
                         n
                         players)) }) -}
0291396d3e3881217b65349ce031a068
  scoreAllPlayers1 ::
    GHC.Maybe.Maybe GameTypes.Player
    -> GHC.Maybe.Maybe GameTypes.Player
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds1 :: GHC.Maybe.Maybe GameTypes.Player) ->
                 case ds1 of wild {
                   GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ GameTypes.Player
                   GHC.Maybe.Just a1
                   -> GHC.Maybe.Just
                        @ GameTypes.Player
                        (case a1 of wild1 { GameTypes.Player id h ds ->
                         case h of wild2 { GameTypes.Hand cards ->
                         GameTypes.Player
                           id
                           wild2
                           (let {
                              temp :: GHC.Integer.Type.Integer
                              = GameLogic.scoreAllPlayers_go1 cards
                            } in
                            case GHC.Integer.Type.gtInteger#
                                   temp
                                   GameLogic.checkPlayerScore1 of wild3 {
                              DEFAULT -> temp
                              1# -> GameLogic.scoreAllPlayers_go cards }) } }) }) -}
6769d04202fbaad07687203b69ff3fd9
  scoreAllPlayers_go :: [GameTypes.Card] -> GHC.Integer.Type.Integer
  {- Arity: 1, Strictness: <S,1*U> -}
a2ef082c5b940a711ba6cd0194f4fc4f
  scoreAllPlayers_go1 :: [GameTypes.Card] -> GHC.Integer.Type.Integer
  {- Arity: 1, Strictness: <S,1*U> -}
368db93480095565deeeabb23adc236b
  setupGame ::
    GHC.Integer.Type.Integer -> GHC.Types.IO GameTypes.Game
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                GameLogic.setupGame1
                  `cast`
                (<GHC.Integer.Type.Integer>_R
                 ->_R Sym (GHC.Types.N:IO[0] <GameTypes.Game>_R)) -}
a4b85ea0bc2e6846098eaea53711a6f8
  setupGame1 ::
    GHC.Integer.Type.Integer
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GameTypes.Game #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (playerCount :: GHC.Integer.Type.Integer)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GameLogic.$wshuffleDeck'
                        10000#
                        GameLogic.setupGame2
                          `cast`
                        (Sym (GHC.Types.N:IO[0] <GameTypes.Deck>_R))
                        eta of ds1 { (#,#) ipv ipv1 ->
                 (# ipv,
                    let {
                      players :: [GHC.Maybe.Maybe GameTypes.Player]
                      = GameLogic.createPlayers playerCount
                    } in
                    case GHC.List.$wlenAcc
                           @ (GHC.Maybe.Maybe GameTypes.Player)
                           players
                           0# of ww2 { DEFAULT ->
                    let {
                      c :: GHC.Integer.Type.Integer = GHC.Integer.Type.smallInteger ww2
                    } in
                    case GameLogic.$wgo ipv1 players c of ww { (#,#) ww1 ww3 ->
                    case GameLogic.$wgo ww1 ww3 c of ww4 { (#,#) ww5 ww6 ->
                    GameTypes.Game
                      ww5
                      (GHC.Base.map
                         @ (GHC.Maybe.Maybe GameTypes.Player)
                         @ (GHC.Maybe.Maybe GameTypes.Player)
                         GameLogic.scoreAllPlayers1
                         ww6) } } } #) }) -}
476285b9c966c0b1a549510be68a1a89
  setupGame2 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GameTypes.Deck #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (w :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 GameLogic.$wshuffle GameLogic.setupGame3 w) -}
6f4f729397dfbf4a9428abcba1fc7a08
  setupGame3 :: [GameTypes.Card]
  {- Unfolding: (GameLogic.setupGame_go
                   (GameTypes.$fEnumSuit_go 0#)) -}
b50b6d5c3e86918811d82f0a12d75fe1
  setupGame4 ::
    [GameTypes.Card] -> [GameTypes.Card] -> GameTypes.Deck
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m,
     Unfolding: (\ (ww :: [GameTypes.Card])[OneShot]
                   (ww1 :: [GameTypes.Card])[OneShot] ->
                 case GameLogic.$wgo1 ww ww1 of ww2 { (#,#) ww3 ww4 ->
                 GameTypes.Deck
                   (GameLogic.setupGame_go1
                      (Data.OldList.transpose
                         @ GameTypes.Card
                         (GHC.Types.:
                            @ [GameTypes.Card]
                            ww3
                            (GHC.Types.:
                               @ [GameTypes.Card]
                               ww4
                               (GHC.Types.[] @ [GameTypes.Card]))))) }) -}
e2c86d34a46f5fda5c90217464e2e264
  setupGame5 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
298d924c7e62d67df65d3c2c12803086
  setupGame_go :: [GameTypes.Suit] -> [GameTypes.Card]
  {- Arity: 1, Strictness: <S,1*U> -}
fbde08a57d6af7710823f7899580cb5e
  setupGame_go1 :: [[GameTypes.Card]] -> [GameTypes.Card]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
136440e3b26ed1c7bfc3b675396d234c
  showPlayerCards ::
    GameTypes.Game -> GameTypes.Id -> GHC.Base.String
  {- Arity: 2, Strictness: <S(LS),1*U(A,1*U)><L,U>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GameTypes.Game) (w1 :: GameTypes.Id) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 GameLogic.$wshowPlayerCards ww2 w1 }) -}
ad96e6d9fca2267423cd44e3df39a151
  showPlayerCards1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   GameLogic.showPlayerCards2) -}
a761f57c21ccfca7ba6add97f9b5b95a
  showPlayerCards2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", "#) -}
2aa9e3604a906af4c75cd956d64bfacf
  showPlayerCards_go :: [GameTypes.Card] -> [[GHC.Types.Char]]
  {- Arity: 1, Strictness: <S,1*U> -}
771f0d70d54f43060bb11281c9e3dbfa
  showPlayerScore ::
    GameTypes.Game -> GameTypes.Id -> GHC.Base.String
  {- Arity: 2, Strictness: <S(LS),1*U(A,1*U)><L,U>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GameTypes.Game) (w1 :: GameTypes.Id) ->
                 case w of ww { GameTypes.Game ww1 ww2 ->
                 GameLogic.$wshowPlayerScore ww2 w1 }) -}
trusted: safe
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

